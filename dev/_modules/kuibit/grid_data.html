

<!doctype html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>kuibit.grid_data &#8212; kuibit 1.3.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/bizstyle.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">kuibit 1.3.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">kuibit.grid_data</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for kuibit.grid_data</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="c1"># Copyright (C) 2020-2021 Gabriele Bozzola</span>
<span class="c1">#</span>
<span class="c1"># Inspired by code originally developed by Wolfgang Kastaun. This file may</span>
<span class="c1"># contain algorithms and/or structures first implemented in</span>
<span class="c1"># GitHub:wokast/PyCactus/PostCactus/grid_data.py</span>
<span class="c1">#</span>
<span class="c1"># This program is free software; you can redistribute it and/or modify it under</span>
<span class="c1"># the terms of the GNU General Public License as published by the Free Software</span>
<span class="c1"># Foundation; either version 3 of the License, or (at your option) any later</span>
<span class="c1"># version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1"># ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
<span class="c1"># FOR A PARTICULAR PURPOSE. See the GNU General Public License for more</span>
<span class="c1"># details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License along with</span>
<span class="c1"># this program; if not, see &lt;https://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;The :py:mod:`~.grid_data` module provides representations of data on uniform</span>
<span class="sd">grids as well as for data on refined grid hierarchies. Standard arithmetic</span>
<span class="sd">operations are supported for those data grids, further methods to interpolate</span>
<span class="sd">and resample. The number of dimensions is arbitrary.</span>

<span class="sd">The important classes defined here are</span>
<span class="sd">- :py:class:`~.UniformGridData` represents data on a uniform grid.</span>
<span class="sd">- :py:class:`~.HierarchicalGridData` represents data on a refined grid</span>
<span class="sd">hierarchy (AMR).</span>

<span class="sd">A :py:class:`~.UniformGridData` object contains a :py:class:`~.UniformGrid` one.</span>
<span class="sd">Similarly, a :py:class:`~.HierarchicalGridData` contains multiple</span>
<span class="sd">:py:class:`~.UniformGridData`.</span>

<span class="sd">We also define :py:class:`~.GridSeries`. This is intended to be used for 1D grid</span>
<span class="sd">data and it is a way to use the infrastructure for ``Series`` for grid data. The</span>
<span class="sd">reason this is useful is that ``Series`` are much simpler and leaner to work</span>
<span class="sd">with.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_right</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">splitext</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">linalg</span>

<span class="kn">from</span> <span class="nn">kuibit</span> <span class="kn">import</span> <span class="n">grid_data_utils</span> <span class="k">as</span> <span class="n">gdu</span>
<span class="kn">from</span> <span class="nn">kuibit.numerical</span> <span class="kn">import</span> <span class="n">BaseNumerical</span>
<span class="kn">from</span> <span class="nn">kuibit.series</span> <span class="kn">import</span> <span class="n">BaseSeries</span>
<span class="kn">from</span> <span class="nn">kuibit.uniform_grid</span> <span class="kn">import</span> <span class="n">UniformGrid</span>


<div class="viewcode-block" id="GridSeries"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.GridSeries">[docs]</a><span class="k">class</span> <span class="nc">GridSeries</span><span class="p">(</span><span class="n">BaseSeries</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;One-dimensional grid data, handled with the Series infrastructure.</span>

<span class="sd">    When the data is one dimensional, sometimes it is more convenient to treat</span>
<span class="sd">    it a series instead of grid data. This class is uses the same infrastructure</span>
<span class="sd">    as :py:class:`~.TimeSeries` and :py:class:`~.FrequencySeries` and has more</span>
<span class="sd">    or less the same features.</span>

<span class="sd">    :ivar x: Coordinates.</span>
<span class="sd">    :type x: 1D NumPy array</span>
<span class="sd">    :ivar y: Values.</span>
<span class="sd">    :type y: 1D NumPy array</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        The third argument can be anything. It is required to ensure</span>
<span class="sd">        compatibility with other series, but it is not used.</span>

<span class="sd">        :param x: Coordinates.</span>
<span class="sd">        :type x: 1D NumPy array</span>
<span class="sd">        :param y: Values.</span>
<span class="sd">        :type y: 1D NumPy array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">guarantee_x_is_monotonic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="UniformGridData"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData">[docs]</a><span class="k">class</span> <span class="nc">UniformGridData</span><span class="p">(</span><span class="n">BaseNumerical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a rectangular data grid with coordinates, supporting</span>
<span class="sd">    common arithmetic operations.</span>

<span class="sd">    :py:class:`~.UniformGridData` is a combination of a</span>
<span class="sd">    :py:class:`~.UniformGrid` (in ``grid`` attribute) and the actual data (in</span>
<span class="sd">    the ``data`` attribute). :py:class:`~.UniformGridData` makes sure that all</span>
<span class="sd">    the operations on these objects are intuitive, meaningful, and consistent.</span>

<span class="sd">    A :py:class:`~.UniformGridData` can be initialized with the default</span>
<span class="sd">    constructor (which takes grid and data), of with the alternative constructor</span>
<span class="sd">    :py:meth:`~.from_grid_structure` (which takes grid details and data).</span>

<span class="sd">    :ivar grid: Uniform grid over which the data is defined.</span>
<span class="sd">    :type grid: :py:class:`~.UniformGrid`</span>
<span class="sd">    :ivar data: The actual data.</span>
<span class="sd">    :type data: NumPy array.</span>

<span class="sd">    :ivar invalid_spline: Whether the spline stored is valid.</span>
<span class="sd">    :type invalid_spline: bool</span>

<span class="sd">    :ivar spline_real: Spline representation of the real part of the data.</span>
<span class="sd">    :type spline_real: SciPy&#39;s RegularGridInterpolator, or None</span>

<span class="sd">    :ivar spline_imag: Spline representation of the imaginary part of the data.</span>
<span class="sd">    :type spline_imag: SciPy&#39;s RegularGridInterpolator, or None</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># We are deriving this from BaseNumerical. This will give all the</span>
    <span class="c1"># mathematical operators for free, as long as we defined _apply_unary</span>
    <span class="c1"># and _apply_binary.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param grid: Uniform grid over which the data is defined.</span>
<span class="sd">        :type grid: :py:class:`~.UniformGrid`</span>
<span class="sd">        :param data: The data.</span>
<span class="sd">        :type data: A NumPy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">UniformGrid</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;grid has to be a UniformGrid&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;grid and data shapes differ </span><span class="si">{</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># We keep this flag around to know when we have to recompute the</span>
        <span class="c1"># splines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalid_spline</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># Here we also define the splines as empty objects so that we know that</span>
        <span class="c1"># they are attributes of the class and they are not uninitialized.</span>
        <span class="c1"># These attributes will store data relevant for evaluating the spline.</span>
        <span class="c1"># This will be an object of type SciPy&#39;s RegularGridInterpolator.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spline_real</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spline_imag</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># This is a class method. It doesn&#39;t depend on the specific instance, and</span>
    <span class="c1"># it is used as an alternative constructor.</span>
<div class="viewcode-block" id="UniformGridData.from_grid_structure"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.from_grid_structure">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_grid_structure</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">x0</span><span class="p">,</span>
        <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ref_level</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">component</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">num_ghost</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">iteration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param x0:    Position of cell center with lowest coordinate.</span>
<span class="sd">        :type x0:     1d NumPy array or list of float.</span>
<span class="sd">        :param dx:     If not None, specifies grid spacing, else grid</span>
<span class="sd">                          spacing is computed from x0, x1, and shape.</span>
<span class="sd">        :type dx:      1d NumPy array or list of float.</span>
<span class="sd">        :param data:      The data.</span>
<span class="sd">        :type data:       A NumPy array.</span>
<span class="sd">        :param ref_level:  Refinement level if this belongs to a hierarchy,</span>
<span class="sd">                          else -1.</span>
<span class="sd">        :type ref_level:   int</span>
<span class="sd">        :param component: Component number if this belongs to a hierarchy,</span>
<span class="sd">                          else -1.</span>
<span class="sd">        :type component:  int</span>
<span class="sd">        :param num_ghost:    Number of ghost zones (default=0)</span>
<span class="sd">        :type num_ghost:     1d NumPy arrary or list of int.</span>
<span class="sd">        :param time:      Time if that makes sense, else None.</span>
<span class="sd">        :type time:       float or None</span>
<span class="sd">        :param iteration: Iteration if that makes sense, else None.</span>
<span class="sd">        :type iteration:  float or None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">UniformGrid</span><span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">x0</span><span class="p">,</span>
            <span class="n">x1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
            <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span>
            <span class="n">ref_level</span><span class="o">=</span><span class="n">ref_level</span><span class="p">,</span>
            <span class="n">component</span><span class="o">=</span><span class="n">component</span><span class="p">,</span>
            <span class="n">num_ghost</span><span class="o">=</span><span class="n">num_ghost</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
            <span class="n">iteration</span><span class="o">=</span><span class="n">iteration</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.coordinates"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return coordinates of the grid points as list of</span>
<span class="sd">        :py:class:`~.UniformGridData`.</span>

<span class="sd">        This can be used for computations involving the coordinates.</span>

<span class="sd">        :returns: Coordinates along each direction.</span>
<span class="sd">        :rtype: list of :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">coord</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates_from_grid</span><span class="p">(</span><span class="n">as_same_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="UniformGridData.coordinates_from_grid"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.coordinates_from_grid">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates_from_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_meshgrid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">as_same_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return coordinates of the grid points.</span>

<span class="sd">        This is equivalent to ``self.grid.coordinates()``.</span>

<span class="sd">        If ``as_meshgrid`` is True, the coordinates are returned as NumPy</span>
<span class="sd">        meshgrid. Otherwise, return the coordinates of the grid points as 1D</span>
<span class="sd">        arrays (schematically, [array for x coordinates, array for y</span>
<span class="sd">        coordinates, ...]).</span>

<span class="sd">        If ``as_same_shape`` is True return the coordinates as an array with the</span>
<span class="sd">        same shape of self and with values the coordinates. This is useful for</span>
<span class="sd">        computations involving the coordinates.</span>

<span class="sd">        :param as_meshgrid: If True, return the coordinates as meshgrid.</span>
<span class="sd">        :type as_meshgrid: bool</span>
<span class="sd">        :param as_same_shape: If True, return the coordinates as a list</span>
<span class="sd">                              or coordinates with the same shape of self</span>
<span class="sd">                              and with values of a given coordinate.</span>
<span class="sd">                              For instance, if ``self.num_dimension = 3`` there</span>
<span class="sd">                              will be three lists with ``shape = self.shape``.</span>
<span class="sd">        :type as_same_shape: bool</span>
<span class="sd">        :returns:  Grid coordinates.</span>
<span class="sd">        :rtype:   list of NumPy arrays with the same shape as grid</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span>
            <span class="n">as_meshgrid</span><span class="o">=</span><span class="n">as_meshgrid</span><span class="p">,</span> <span class="n">as_same_shape</span><span class="o">=</span><span class="n">as_same_shape</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.coordinates_meshgrid"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.coordinates_meshgrid">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates_meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return coordinates of the grid points as NumPy meshgrid.</span>

<span class="sd">        This is syntactic sugar useful for plotting with matplotlib.</span>

<span class="sd">        :returns:  Grid coordinates.</span>
<span class="sd">        :rtype:   list of NumPy arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates_from_grid</span><span class="p">(</span><span class="n">as_meshgrid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the data, but transposed.</span>

<span class="sd">        This is useful when plotting, because we store data in a matrix form,</span>
<span class="sd">        which is the transposed of what we are used to thinking about coordinates</span>
<span class="sd">        (ie, the first index is not ``x``).</span>

<span class="sd">        :returns: Data in a coordinate-friendly form.</span>
<span class="sd">        :rtype: NumPy array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

<div class="viewcode-block" id="UniformGridData.save"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save data and grid information to a file.</span>

<span class="sd">        Unless the file extension is ``npz``, the output file will ASCII. In</span>
<span class="sd">        this case, compression is supported. To enable compression, just append</span>
<span class="sd">        ``bz`` or ``gz`` to the extension. All the unknown arguments are passed</span>
<span class="sd">        to ``np.savetxt``. The backend used in this case does not support</span>
<span class="sd">        writing 3D or larger arrays to disk as ASCII, so all the arrays are</span>
<span class="sd">        reshaped to 1D.</span>

<span class="sd">        If the file extension is ``npz``, then save the grid with this</span>
<span class="sd">        NumPy-specific format (compressed).</span>

<span class="sd">        If you look for performance, use ``npz``, if you want a file that you</span>
<span class="sd">        can easily read everywhere, use ASCII.</span>

<span class="sd">        The file output with this method can be read with the</span>
<span class="sd">        :py:func:`~.load_UniformGridData` function.</span>

<span class="sd">        :param file_name: Path (with extension) of the output file.</span>
<span class="sd">        :type file_name: str</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Discarding mask information.&quot;</span><span class="p">,</span>
                <span class="ne">RuntimeWarning</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">splitext</span><span class="p">(</span><span class="n">file_name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.npz&quot;</span><span class="p">:</span>
            <span class="c1"># Time and iterations could be None, in that case, we don&#39;t add them</span>
            <span class="n">others</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">others</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">})</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">others</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;iteration&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">})</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span>
                <span class="n">file_name</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">x0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span>
                <span class="n">dx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span>
                <span class="n">ref_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span>
                <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">,</span>
                <span class="n">num_ghost</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="o">**</span><span class="n">others</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># ASCII file</span>
        <span class="c1">#</span>
        <span class="c1"># In the header we save all the metadata for the grid.</span>
        <span class="c1"># We will use colons to read the data from the comment</span>
        <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;shape: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;x0: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;dx: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;ref_level: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;component: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;num_ghost: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;time: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;iteration: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span>
            <span class="n">file_name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
            <span class="p">),</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lower corner.</span>

<span class="sd">        :returns: Center of lowest corner grid point.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">x0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of cells across each dimension.</span>

<span class="sd">        :returns: Number of cells across each dimension.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Upper corner.</span>

<span class="sd">        :returns: Center of top corner grid point.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">x1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lower corner.</span>

<span class="sd">        Alias for :py:meth:`~.x0`.</span>

<span class="sd">        :returns: Center of lowest corner grid point.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Grid spacing.</span>

<span class="sd">        :returns: Cell size across each dimension.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dx</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Grid spacing.</span>

<span class="sd">        Alias for :py:meth:`~.dx`.</span>

<span class="sd">        :returns: Cell size across each dimension.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_ghost</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of ghost zones.</span>

<span class="sd">        :returns: Number of ghost zones across each dimension.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">num_ghost</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ref_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Refinement level number.</span>

<span class="sd">        :returns: Refinement level number.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">ref_level</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Component number.</span>

<span class="sd">        :returns: Component number.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">component</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Time.</span>

<span class="sd">        :returns: Time.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">time</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iteration number</span>

<span class="sd">        :returns: Iteration number.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">iteration</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_make_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Private function to make spline representation of the data using</span>
<span class="sd">        ``scipy.interpolate.RegularGridInterpolator``.</span>

<span class="sd">        Only nearest neighbor or multilinear interpolations are available.</span>

<span class="sd">        Computing spline is memory intenstive: 150 MB/million points.</span>

<span class="sd">        This function is not meant to be called directly.</span>

<span class="sd">        :param k: Order of the interpolation (k = 0 or 1).</span>
<span class="sd">        :type k:  int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Splines with masked data are not supported.&quot;</span><span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Order for splines for dimensions &gt; 2 must be 0 or 1&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Here k is 0 or 1</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span> <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;linear&quot;</span>

        <span class="c1"># Our grid is cell-centered, so it is perfecly valid to evaluate a point</span>
        <span class="c1"># that it is outside coords, as long as it is within 0.5 * dx. For</span>
        <span class="c1"># example, if the grid is linear from 0 to 10 with dx = 1, the point</span>
        <span class="c1"># -0.25 is in the grid. To account for this in splines (to avoid that</span>
        <span class="c1"># they throw an error), we add another point at the two boundaries. This</span>
        <span class="c1"># point as the same value as the last point (which is equivalent to a</span>
        <span class="c1"># 0th order interpolation at the very last half cell).</span>

        <span class="c1"># With this, the grid has uneven spacing.</span>
        <span class="c1"># Add an element at the beginning and end</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">index</span><span class="p">]],</span>
                    <span class="n">coord</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">index</span><span class="p">]],</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Add the border</span>
        <span class="n">data_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spline_real</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">RegularGridInterpolator</span><span class="p">(</span>
            <span class="n">coords</span><span class="p">,</span>
            <span class="n">data_real</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">bounds_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
            <span class="n">data_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spline_imag</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">RegularGridInterpolator</span><span class="p">(</span>
                <span class="n">coords</span><span class="p">,</span>
                <span class="n">data_imag</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">bounds_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">invalid_spline</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_nearest_neighbor_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return data of nearest neighbors of given points x.</span>

<span class="sd">        :param x: Points where to evaluate the data.</span>
<span class="sd">        :type x: 1D NumPy array of float, or :py:class:`~.UniformGrid`</span>

<span class="sd">        :param ext: How to deal values outside the boundaries. Values outside</span>
<span class="sd">                    the interval are set to 0 if ``ext=1``,</span>
<span class="sd">                    or an error is raised if ``ext=2``.</span>
<span class="sd">        :type ext:  int</span>

<span class="sd">        :returns: Values of the data evaluated on the input ``x``.</span>
<span class="sd">        :rtype:   1D NumPy array or float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># To implement the piecewise constant spline, we just lookup the</span>
        <span class="c1"># data, so first we get the corresponding indices.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coordinates_to_indices</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="c1"># We need the array version because we are going to modify the values</span>
        <span class="n">indices_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="c1"># Here we have to directly implement the support for ext = 1 and</span>
        <span class="c1"># ext = 2. We find all the points that are outside the</span>
        <span class="c1"># boundaries.</span>

        <span class="c1"># Here we check for every point if they have have negative index</span>
        <span class="c1"># or index larger than the shape (number of points)</span>
        <span class="n">outside_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indices_arr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indices_arr</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">outside_indices</span><span class="p">):</span>
                <span class="c1"># For ext = 2, we simply have the raise an error if we have</span>
                <span class="c1"># any outside_index</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Point outside the grid&quot;</span><span class="p">)</span>
            <span class="c1"># NumPy fancy indexing consists in a list of N tuples each</span>
            <span class="c1"># representing a coordinate, so we have to reshape the indices.</span>
            <span class="c1"># Here we use this trick:</span>
            <span class="c1"># *indices unpacks the indices so that the iterator is over each</span>
            <span class="c1"># point. Then, we zip them, which means that we take one element</span>
            <span class="c1"># at the time from each dimension. Finally, we convert this iterator</span>
            <span class="c1"># to a tuple</span>
            <span class="n">take_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">take_indices</span><span class="p">]</span>

        <span class="c1"># Here we are with ext = 1. If we were to call self.data[indices], we</span>
        <span class="c1"># would have errors because we are trying to access elements outside the</span>
        <span class="c1"># array. Therefore, we change these indices to a value. We will</span>
        <span class="c1"># overwrite that value with 0 later.</span>

        <span class="c1"># Here we substitute those elements that are outside with the point</span>
        <span class="c1"># (0, 0, 0, ...) (N zeros with 0 is num dimension)</span>
        <span class="n">indices_arr</span><span class="p">[</span><span class="n">outside_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># See comment ~10 lines above for what this means</span>
        <span class="n">take_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">indices_arr</span><span class="p">))</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">take_indices</span><span class="p">]</span>

        <span class="n">ret</span><span class="p">[</span><span class="n">outside_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">ret</span>

<div class="viewcode-block" id="UniformGridData.evaluate_with_spline"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.evaluate_with_spline">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_with_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the spline on the points ``x``.</span>

<span class="sd">        Values outside the interval are set to 0 if ``ext=1``, or a</span>
<span class="sd">        ``ValueError`` is raised if ``ext=2``.</span>

<span class="sd">        This method is meant to be used only if you want to use a different ext</span>
<span class="sd">        for a specific call, otherwise, just use __call__.</span>

<span class="sd">        :param x: Points where to evaluate the data.</span>
<span class="sd">        :type x: 1D NumPy array of float, or :py:class:`~.UniformGrid`</span>

<span class="sd">        :param ext: How to deal values outside the boundaries. Values outside</span>
<span class="sd">                    the interval are set to 0 if ``ext=1``,</span>
<span class="sd">                    or an error is raised if ``ext=2``.</span>
<span class="sd">        :type ext:  int</span>

<span class="sd">        :returns: Values of the data evaluated on the input ``x``.</span>
<span class="sd">        :rtype:   1D NumPy array or float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ext = 0 is extrapolation and ext = 3 is setting the boundary</span>
        <span class="c1"># value. We cannot do this with RegularGridInterpolator</span>

        <span class="c1"># TODO (FEATURE): Implement ext = 3</span>
        <span class="c1">#</span>
        <span class="c1"># We can implement ext = 3 by clamping the indices.</span>

        <span class="k">if</span> <span class="n">ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only ext=1 or ext=2 are available&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">UniformGrid</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">num_dimensions</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Incompatible dimensions between input and self&quot;</span>
                <span class="p">)</span>
            <span class="c1"># The way we want the coordinates is like as an array with the same</span>
            <span class="c1"># shape of the grid and with values the coordinates (as arrays).</span>
            <span class="c1"># This is similar to as_same_shape, but the coordinates have to be</span>
            <span class="c1"># the value, and not the first index.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">as_same_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Now we make sure we have an array</span>
        <span class="n">x_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># We determine what is the shape of the points forgetting about</span>
        <span class="c1"># their dimensionality (which we don&#39;t need). We use this reshape</span>
        <span class="c1"># the output.</span>
        <span class="n">points_shape</span> <span class="o">=</span> <span class="n">x_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Next, we reshape up to the last axis, which means that</span>
        <span class="c1"># now we have a collection of points</span>
        <span class="n">x_arr</span> <span class="o">=</span> <span class="n">x_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">piecewise_constant</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_extended_dimensions</span>
        <span class="p">):</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nearest_neighbor_interpolation</span><span class="p">(</span><span class="n">x_arr</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We are here only with method = linear</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalid_spline</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_make_spline</span><span class="p">()</span>

            <span class="c1"># ext = 1 is setting to 0. We set fill_value to 0, so this is the</span>
            <span class="c1"># default behavior. We change the bounds_error attribute in</span>
            <span class="c1"># RegularGridInterpolator that controls this. By default, we set it</span>
            <span class="c1"># to raise an error. We reset it to True when we are done.</span>
            <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spline_real</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spline_imag</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">def</span> <span class="nf">apply_spline</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
                <span class="n">y_real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline_real</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                    <span class="n">y_imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline_imag</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">y_real</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">y_imag</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">y_real</span>
                <span class="k">return</span> <span class="n">ret</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="n">apply_spline</span><span class="p">(</span><span class="n">x_arr</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spline_real</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spline_imag</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Now we have to reconstruct the correct return shape.</span>
        <span class="c1"># First, we determine what is the dimensionality of the output</span>
        <span class="c1"># of function</span>
        <span class="n">shape_function_return</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># And append this to the shape of the points</span>
        <span class="n">ret_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">points_shape</span> <span class="o">+</span> <span class="n">shape_function_return</span><span class="p">)</span>
        <span class="c1"># Finally, we reshape</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># TODO (FEATURE): Avoid splines when the data is already available.</span>
        <span class="c1">#</span>
        <span class="c1"># At the moment, the splines are calculated even on points in which</span>
        <span class="c1"># data is available. This is probably inefficient.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_with_spline</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="UniformGridData.sliced"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.sliced">[docs]</a>    <span class="k">def</span> <span class="nf">sliced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.UniformGridData` obtained slicing the current one.</span>

<span class="sd">        ``cut`` specifies how to slice the data. It has to be an array with the</span>
<span class="sd">        same number of dimensions of the data. In the entries where ``cut`` is</span>
<span class="sd">        None, that dimension is kept, where it is a number, the data is cut</span>
<span class="sd">        fixing that coordinate. For example, for a 2D array, if ``cut`` is</span>
<span class="sd">        ``[None, 2]``, the cut will be with ``y = 2``.</span>

<span class="sd">        If ``resample`` is True, you can cut at any point and we will compute</span>
<span class="sd">        the values with multilinear interpolation. If ``resample`` is False, we</span>
<span class="sd">        will use the data already available.</span>

<span class="sd">        In doing this, dimensions that are only one grid point are lost.</span>

<span class="sd">        :param cut: How to slice the array. None entries mean &quot;keep that dimension&quot;.</span>
<span class="sd">        :type cut:  array or list with dimension</span>
<span class="sd">        :param resample: Whether to use multilinear interpolation to compute the</span>
<span class="sd">                         data or simply use the value of the closest point.</span>
<span class="sd">        :type resample: bool</span>

<span class="sd">        :returns: A sliced :py:class:`~.UniformGridData`.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO (REFACTORING): Don&#39;t repet yourself!</span>
        <span class="c1">#</span>
        <span class="c1"># There is redundancy in how this function is written. It should be easy</span>
        <span class="c1"># to simplify it.</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cut</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cut</span><span class="si">}</span><span class="s2"> has wrong dimension. Cut has to have the same&quot;</span>
                <span class="s2">&quot; dimensions as the grid, and has to have None on the&quot;</span>
                <span class="s2">&quot; dimension you want to keep&quot;</span>
            <span class="p">)</span>

        <span class="c1"># First we check that we actually have to resample and cut is not all</span>
        <span class="c1"># None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cut</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># If we have to resample, we simply prepare a new UniformGrid with the</span>
        <span class="c1"># coordiantes that we want. We are going to resample keeping the number</span>
        <span class="c1"># of dimensions fixed, but setting shape of 1 grid point on those</span>
        <span class="c1"># dimensions that have to be cut. Then, we flatten the UniformGridData</span>
        <span class="c1"># (which removes dimensions with one grid point).</span>

        <span class="k">if</span> <span class="n">resample</span><span class="p">:</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">new_x0</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">new_ghost</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="n">new_grid</span> <span class="o">=</span> <span class="n">UniformGrid</span><span class="p">(</span>
                <span class="n">new_shape</span><span class="p">,</span>
                <span class="n">x0</span><span class="o">=</span><span class="n">new_x0</span><span class="p">,</span>
                <span class="n">dx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span>
                <span class="n">ref_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span>
                <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">,</span>
                <span class="n">num_ghost</span><span class="o">=</span><span class="n">new_ghost</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                <span class="n">iteration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># We used &quot;resampled&quot; to make a copy, then &quot;flat_dimensions_remove&quot;</span>
            <span class="c1"># to modify that (so that we don&#39;t make a new copy)</span>
            <span class="n">sliced_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">(</span><span class="n">new_grid</span><span class="p">)</span>
            <span class="n">sliced_data</span><span class="o">.</span><span class="n">flat_dimensions_remove</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">sliced_data</span>

        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="n">new_x0</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="n">new_dx</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="n">new_ghost</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">]</span>

        <span class="n">new_grid</span> <span class="o">=</span> <span class="n">UniformGrid</span><span class="p">(</span>
            <span class="n">new_shape</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="n">new_x0</span><span class="p">,</span>
            <span class="n">dx</span><span class="o">=</span><span class="n">new_dx</span><span class="p">,</span>
            <span class="n">ref_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span>
            <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">,</span>
            <span class="n">num_ghost</span><span class="o">=</span><span class="n">new_ghost</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="n">iteration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Here we are not resampling, so we just have to properly cut the array.</span>
        <span class="c1"># We prepare a slicer array which defines where to cut.</span>
        <span class="n">slicer</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># We walk through all the dimensions, if some unreasonable cuts are</span>
        <span class="c1"># requsted, we throw an error, otherwise we find the index of the</span>
        <span class="c1"># data element where to cut.</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">slicer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">lowest_vertex</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                    <span class="o">&lt;=</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                    <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">highest_vertex</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="c1"># The slice method in HierarchicalGridData matches this</span>
                    <span class="c1"># error message, so you change it, update the corresponding</span>
                    <span class="c1"># method.</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cut point is outside the grid&quot;</span><span class="p">)</span>
                <span class="c1"># Transform from coordinate to index</span>
                <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
                <span class="n">slicer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="n">slicer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slicer</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">slicer</span><span class="p">])</span></div>

<div class="viewcode-block" id="UniformGridData.slice"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.slice">[docs]</a>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice the data along given direction.</span>

<span class="sd">        ``cut`` specifies how to slice the data. It has to be an array with the</span>
<span class="sd">        same number of dimensions of the data. In the entries where ``cut`` is</span>
<span class="sd">        None, that dimension is kept, where it is a number, the data is cut</span>
<span class="sd">        fixing that coordinate. For example, for a 2D array, if ``cut`` is</span>
<span class="sd">        ``[None, 2]``, the cut will be with ``y = 2``.</span>

<span class="sd">        If ``resample`` is True, you can cut at any point and we will compute</span>
<span class="sd">        the values with multilinear interpolation. If ``resample`` is False, we</span>
<span class="sd">        will use the data already available.</span>

<span class="sd">        In doing this, dimensions that are only one grid point are lost.</span>

<span class="sd">        :param cut: How to slice the array. None entries mean &quot;keep that dimension&quot;.</span>
<span class="sd">        :type cut:  array or list with dimension</span>
<span class="sd">        :param resample: Whether to use multilinear interpolation to compute the</span>
<span class="sd">                         data or simply use the value of the closest point.</span>
<span class="sd">        :type resample: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sliced</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="n">cut</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.resampled"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.resampled">[docs]</a>    <span class="k">def</span> <span class="nf">resampled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_grid</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.UniformGridData` resampled to ``new_grid``.</span>

<span class="sd">        If you want to resample without using the spline, and you want a nearest</span>
<span class="sd">        neighbor resampling, pass the keyword ``piecewise_constant=True``. This</span>
<span class="sd">        may be a good choice for data with large discontinuities, where the</span>
<span class="sd">        splines are ineffective.</span>

<span class="sd">        :param new_grid: New independent variable.</span>
<span class="sd">        :type new_grid:  1D NumPy array or list of float</span>
<span class="sd">        :param ext: How to handle points outside the data interval.</span>
<span class="sd">        :type ext: 1 for returning zero, 2 for ``ValueError``,</span>
<span class="sd">        :param piecewise_constant: Do not use splines, use the nearest neighbors.</span>
<span class="sd">        :type piecewise_constant: bool</span>
<span class="sd">        :returns: Resampled data.</span>
<span class="sd">        :rtype:   :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_grid</span><span class="p">,</span> <span class="n">UniformGrid</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Resample takes another UniformGrid&quot;</span><span class="p">)</span>

        <span class="c1"># If grid is the same, there&#39;s no need to resample</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">==</span> <span class="n">new_grid</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
            <span class="n">new_grid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_with_spline</span><span class="p">(</span>
                <span class="n">new_grid</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="n">piecewise_constant</span>
            <span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.is_complex"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.is_complex">[docs]</a>    <span class="k">def</span> <span class="nf">is_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the data is complex.</span>

<span class="sd">        :returns:  True if the data is complex, false if it is not.</span>
<span class="sd">        :rtype:   bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return where the data is valid (according to the mask).</span>

<span class="sd">        :returns: Array of True/False of the same shape of the data.</span>
<span class="sd">                  False where the data is valid, True where is not.</span>
<span class="sd">        :rtype: array of bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">mask</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

<div class="viewcode-block" id="UniformGridData.is_masked"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.is_masked">[docs]</a>    <span class="k">def</span> <span class="nf">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the data is masked.</span>

<span class="sd">        :returns:  True if the data is masked, false if it is not.</span>
<span class="sd">        :rtype:   bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span>

    <span class="k">def</span> <span class="nf">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the method ``f`` to ``self``, modifying ``self``.</span>

<span class="sd">        This function is used to implement those methods that act on the object</span>
<span class="sd">        starting from methods that return a new object. The function has to</span>
<span class="sd">        return a new copy of the object (not a reference).</span>

<span class="sd">        :param f: Method to apply.</span>
<span class="sd">        :type f: callable</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">ret</span><span class="o">.</span><span class="n">data</span>
        <span class="c1"># We have to recompute the splines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalid_spline</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="UniformGridData.flat_dimensions_removed"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.flat_dimensions_removed">[docs]</a>    <span class="k">def</span> <span class="nf">flat_dimensions_removed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.UniformGridData` with dimensions of one grid point</span>
<span class="sd">        removed.</span>

<span class="sd">        :returns: New :py:class:`UniformGridData` without flat dimensions.</span>
<span class="sd">        :rtype: :py:class:`UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">flat_dimensions_removed</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_grid</span><span class="p">,</span> <span class="n">new_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.flat_dimensions_remove"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.flat_dimensions_remove">[docs]</a>    <span class="k">def</span> <span class="nf">flat_dimensions_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove dimensions which are only one gridpoint large.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flat_dimensions_removed</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.ghost_zones_removed"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.ghost_zones_removed">[docs]</a>    <span class="k">def</span> <span class="nf">ghost_zones_removed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`UniformGridData` with all the ghost zones removed.</span>

<span class="sd">        :returns: New :py:class:`UniformGridData` without ghostzones.</span>
<span class="sd">        :rtype: :py:class:`UniformGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">new_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">ghost_zones_removed</span><span class="p">()</span>
        <span class="c1"># We remove the borders from the data using the slicing operator</span>
        <span class="n">slicer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="nb">slice</span><span class="p">(</span><span class="n">ghost_zones</span><span class="p">,</span> <span class="o">-</span><span class="n">ghost_zones</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ghost_zones</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_grid</span><span class="p">,</span> <span class="n">new_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.ghost_zones_remove"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.ghost_zones_remove">[docs]</a>    <span class="k">def</span> <span class="nf">ghost_zones_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all the ghost zones.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ghost_zones_removed</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.reflection_symmetry_undone"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.reflection_symmetry_undone">[docs]</a>    <span class="k">def</span> <span class="nf">reflection_symmetry_undone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">parity</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new UniformGridData with reflection symmetry undo for the given dimension.</span>

<span class="sd">        The parameter ``parity`` determines how to fill the data.</span>

<span class="sd">        This method works only if the data crosses the value 0 along the given</span>
<span class="sd">        dimension.</span>

<span class="sd">        We assume that the reflection will always be from the positive side to</span>
<span class="sd">        the negative. Pre-existing data in the negative side will be overwritten.</span>

<span class="sd">        This will change the shape of the object.</span>

<span class="sd">        :param dimension: Dimension that has to be reflected.</span>
<span class="sd">        :type dimension: int</span>

<span class="sd">        :param parity: Fill the data assuming that the function is even (parity = 1),</span>
<span class="sd">                       or odd (parity = -1).</span>
<span class="sd">        :type parity: 1 or -1</span>

<span class="sd">        :returns: New :py:class:`UniformGridData` with values explicitly set for</span>
<span class="sd">                  reflected data.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># NOTE: this cannot be applied to HierarchicalGridData. In that case we would</span>
        <span class="c1"># need to add new components all together.</span>

        <span class="c1"># We assume that we are going to reflect from the positive side to the</span>
        <span class="c1"># negative</span>

        <span class="c1"># 0 is not in the data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot reflect data that does not cross 0&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">parity</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Parity has to be either 1 or -1, cannot be </span><span class="si">{</span><span class="n">parity</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># See self.grid.coordinates_to_indices():</span>
        <span class="c1"># We convert the coordinate 0.0 to the index, this will always overestimate, so</span>
        <span class="c1"># it will always be the first positive</span>
        <span class="n">index_first_positive</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
            <span class="p">(</span><span class="mf">0.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">[</span><span class="n">dimension</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="p">)</span>

        <span class="c1"># Next we check that the grid is indeed symmetric about 0. So, the first</span>
        <span class="c1"># positive point has to be such that, when reflected, it has the correct</span>
        <span class="c1"># dx.</span>
        <span class="c1">#</span>
        <span class="c1"># For example: -2, -0.75, 0.5, 1.75, 3 is not a good grid. The dx here</span>
        <span class="c1"># is 1.25, but, when reflected, 0.5 -&gt; -0.5, and the dx would be 1.</span>
        <span class="c1">#</span>
        <span class="c1"># But -2, 1, 3 is because 1 -&gt; -1, and dx = 2</span>

        <span class="c1"># Compare UniformGrid.indices_to_coordinates</span>
        <span class="n">coordinates_first_positive_dim</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">index_first_positive</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># This could actually be 0. If it is zero, we have to take this into</span>
        <span class="c1"># account. The zero value should not be copied.</span>
        <span class="n">first_element_is_zero</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">1</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">coordinates_first_positive_dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span>
            <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span>

        <span class="c1"># 2 * coordinates_first_positive_dim = first_positive - (-first_positive)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">first_element_is_zero</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="n">coordinates_first_positive_dim</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span>
                <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Grid is not symmetric along dimension </span><span class="si">{</span><span class="n">dimension</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">num_elements_to_copy</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
            <span class="o">-</span> <span class="n">index_first_positive</span>
            <span class="o">-</span> <span class="n">first_element_is_zero</span>
        <span class="p">)</span>

        <span class="n">new_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># The new shape is the old shape + num_elements_to_copy - the negative</span>
        <span class="c1"># values (that are going to be overwritten) and the possible zero.</span>
        <span class="n">new_shape</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">+=</span> <span class="n">num_elements_to_copy</span> <span class="o">-</span> <span class="n">index_first_positive</span>

        <span class="c1"># Prepare the output array</span>
        <span class="c1"># We overwrite it with the data</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># These are slicers that copy everything. This is what we want, except</span>
        <span class="c1"># for the given dimension.</span>
        <span class="n">destination</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
        <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
        <span class="c1"># Copy in indices 0, 1, ..., num_elements_to_copy - 1</span>
        <span class="n">destination</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_elements_to_copy</span><span class="p">)</span>
        <span class="c1"># We have to read the data backwards from the source, so we read from the end</span>
        <span class="c1"># to index_first_positive - 1 (not included)</span>
        <span class="n">source</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span>
            <span class="n">index_first_positive</span> <span class="o">+</span> <span class="n">first_element_is_zero</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">new_data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">destination</span><span class="p">)]</span> <span class="o">=</span> <span class="n">parity</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">source</span><span class="p">)]</span>

        <span class="c1"># Now we copy the data we already had</span>
        <span class="c1">#</span>
        <span class="c1"># num_elements_to_copy - 1 because we start counting from 0</span>
        <span class="n">destination</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span>
            <span class="n">num_elements_to_copy</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">source</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index_first_positive</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dimension</span><span class="p">])</span>

        <span class="n">new_data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">destination</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">source</span><span class="p">)]</span>

        <span class="c1"># And we need to extend the grid too</span>

        <span class="c1"># Compute the new x0</span>
        <span class="n">new_x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="n">new_x0</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">x1</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>

        <span class="n">new_grid</span> <span class="o">=</span> <span class="n">UniformGrid</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">new_shape</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="n">new_x0</span><span class="p">,</span>
            <span class="n">x1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span>
            <span class="n">dx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span>
            <span class="n">ref_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span>
            <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">component</span><span class="p">,</span>
            <span class="n">num_ghost</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="n">iteration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_grid</span><span class="p">,</span> <span class="n">new_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.reflection_symmetry_undo"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.reflection_symmetry_undo">[docs]</a>    <span class="k">def</span> <span class="nf">reflection_symmetry_undo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">parity</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Undo reflection symmetry for the given dimension.</span>

<span class="sd">        This method works only if the data crosses the value 0 along the given dimension.</span>

<span class="sd">        This will change the shape of the object.</span>

<span class="sd">        :param dimension: Dimension that has to be reflected.</span>
<span class="sd">        :type dimension: int</span>

<span class="sd">        :param parity: Fill the data assuming that the function is even (parity = 1),</span>
<span class="sd">                       or odd (parity = -1).</span>
<span class="sd">        :type parity: 1 or -1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reflection_symmetry_undone</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">parity</span><span class="o">=</span><span class="n">parity</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.dx_changed"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.dx_changed">[docs]</a>    <span class="k">def</span> <span class="nf">dx_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dx</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`UniformGridData` with the same grid extent, but with</span>
<span class="sd">        a new spacing. This effectively up-samples or down-samples the grid.</span>

<span class="sd">        Missing data is obtained with splines.</span>

<span class="sd">        ``new_dx`` has to be an integer multiple of the current ``dx`` (or vice</span>
<span class="sd">        versa).</span>

<span class="sd">        If ``piecewise_constant=True``, the missing information is obtained with</span>
<span class="sd">        from the nearest neighbors.</span>

<span class="sd">        :param new_dx: Do not use splines, use the nearest neighbors.</span>
<span class="sd">        :type new_dx: 1d NumPy array</span>
<span class="sd">        :param piecewise_constant: Do not use splines, use the nearest neighbors.</span>
<span class="sd">        :type piecewise_constant: bool</span>

<span class="sd">        :returns: Data with new grid spacing ``new_dx``.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_dx</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;dx has to be a list or an array. </span><span class="si">{</span><span class="n">new_dx</span><span class="si">}</span><span class="s2"> is not&quot;</span>
            <span class="p">)</span>

        <span class="c1"># First, we check that new_dx is and dx are compatible</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_dx</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Provided dx has not the correct number of dimensions&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If we don&#39;t have to change dx, just return a copy</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">new_dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">new</span> <span class="o">/</span> <span class="n">old</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">old</span> <span class="o">/</span> <span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Provided dx is not an integer multiple or factor of current dx&quot;</span>
                <span class="p">)</span>

        <span class="c1"># new_dx can have zero entries, for which a shape of 1 should correspond.</span>
        <span class="c1"># There can zero entries, we substitute them with -1, so that we</span>
        <span class="c1"># can identify them as negative numbers</span>
        <span class="n">new_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx</span> <span class="k">if</span> <span class="n">dx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">new_dx</span><span class="p">])</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="n">new_dx</span> <span class="o">+</span> <span class="mf">1.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span> <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new_shape</span><span class="p">])</span>

        <span class="n">new_grid</span> <span class="o">=</span> <span class="n">UniformGrid</span><span class="p">(</span>
            <span class="n">new_shape</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span>
            <span class="n">dx</span><span class="o">=</span><span class="n">new_dx</span><span class="p">,</span>
            <span class="n">ref_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span>
            <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">,</span>
            <span class="n">num_ghost</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="n">iteration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">(</span><span class="n">new_grid</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="n">piecewise_constant</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.dx_change"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.dx_change">[docs]</a>    <span class="k">def</span> <span class="nf">dx_change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dx</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Up-samples or down-samples the grid data.</span>

<span class="sd">        Missing data is obtained with splines.</span>

<span class="sd">        ``new_dx`` has to be an integer multiple of the current ``dx`` (or vice</span>
<span class="sd">        versa).</span>

<span class="sd">        If ``piecewise_constant=True``, the missing information is obtained with</span>
<span class="sd">        from the nearest neighbors.</span>

<span class="sd">        :param new_dx: Do not use splines, use the nearest neighbors.</span>
<span class="sd">        :type new_dx: 1d NumPy array</span>
<span class="sd">        :param piecewise_constant: Do not use splines, use the nearest neighbors.</span>
<span class="sd">        :type piecewise_constant: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dx_changed</span><span class="p">,</span> <span class="n">new_dx</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="n">piecewise_constant</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.copy"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a deep of self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of dimensions of the grid.</span>

<span class="sd">        :returns: Number of dimensions of the grid.</span>
<span class="sd">        :rtype:   float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">num_dimensions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_extended_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of dimensions with size larger than one gridpoint.</span>

<span class="sd">        :returns: The number of extended dimensions (the ones with more than one cell).</span>
<span class="sd">        :rtype:   int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">num_extended_dimensions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">extended_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an array of bools with whether a dimension has more than one</span>
<span class="sd">        point or not.</span>

<span class="sd">        :returns: Dimensions with more than one point.</span>
<span class="sd">        :rtype:   1d NumPy of bools</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">extended_dimensions</span>

<div class="viewcode-block" id="UniformGridData.integral"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.integral">[docs]</a>    <span class="k">def</span> <span class="nf">integral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the integral over the whole volume of the grid.</span>

<span class="sd">        :returns: The integral computed as volume-weighted sum.</span>
<span class="sd">        :rtype:   float (or complex if data is complex).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dv</span></div>

<div class="viewcode-block" id="UniformGridData.mean"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the mean of the data over the whole volume of the grid.</span>

<span class="sd">        :returns: Arithmetic mean of the data.</span>
<span class="sd">        :rtype:   float (or complex if data is complex).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>

    <span class="n">average</span> <span class="o">=</span> <span class="n">mean</span>

<div class="viewcode-block" id="UniformGridData.norm_p"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.norm_p">[docs]</a>    <span class="k">def</span> <span class="nf">norm_p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the norm of order ``p`` over the whole volume of the grid.</span>

<span class="sd">        :math:`\|u\|_p = (\sum \|u\|^p dv)^1/p`</span>

<span class="sd">        :param order: Order of the norm.</span>
<span class="sd">        :type order: int</span>

<span class="sd">        :returns: The norm2 computed as volume-weighted sum.</span>
<span class="sd">        :rtype:   float (or complex if data is complex).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="nb">ord</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dv</span> <span class="o">**</span> <span class="p">(</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="n">order</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.norm2"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.norm2">[docs]</a>    <span class="k">def</span> <span class="nf">norm2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the norm over the whole volume of the grid.</span>

<span class="sd">        :math:`\|u\|_2 = (\sum \|u\|^2 dv)^1/2`</span>

<span class="sd">        :returns: The norm2 computed as volume-weighted sum.</span>
<span class="sd">        :rtype:   float (or complex if data is complex).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_p</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.norm1"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.norm1">[docs]</a>    <span class="k">def</span> <span class="nf">norm1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the norm over the whole volume of the grid.</span>

<span class="sd">        :math:`\|u\|_1 = \sum \|u\| dv`</span>

<span class="sd">        :returns: The norm2 computed as volume-weighted sum.</span>
<span class="sd">        :rtype:   float (or complex if data is complex).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_p</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.histogram"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.histogram">[docs]</a>    <span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">min_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">num_bins</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the 1D Histogram of the data.</span>

<span class="sd">        :param weights:    The weight for each cell. Default is one.</span>
<span class="sd">        :type weights:     :py:class:`~.UniformGridData` or NumPy array of same shape or None.</span>
<span class="sd">        :param min_value: Lower bound of data to consider. Default is data range.</span>
<span class="sd">        :type min_value: float or None</span>
<span class="sd">        :param max_value: Upper bound of data to consider. Default is data range.</span>
<span class="sd">        :type max_value: float or None</span>
<span class="sd">        :param num_bins: Number of bins to create.</span>
<span class="sd">        :type num_bins: int &gt; 1</span>

<span class="sd">        :returns: The positions of the data bins and the distribution.</span>
<span class="sd">        :rtype:   tuple of two 1D NumPy arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Function from Wolfgang Kastaun&#39;s PostCactus</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Histogram only works with real data&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">UniformGridData</span><span class="p">):</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Check that we have a NumPy array or None</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Weights has to be a UniformGrid, NumPy array or None&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">),</span>
            <span class="n">bins</span><span class="o">=</span><span class="n">num_bins</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.percentiles"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.percentiles">[docs]</a>    <span class="k">def</span> <span class="nf">percentiles</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fractions</span><span class="p">,</span>
        <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">relative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">min_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">num_bins</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find values for which a given fraction(s) of the data is smaller.</span>

<span class="sd">        Optionally, the cells can have an optional weight, and absolute counts</span>
<span class="sd">        can be used instead of fraction.</span>

<span class="sd">        :param fractions: List of fraction/absolute values.</span>
<span class="sd">        :type fractions:  list or array of floats</span>
<span class="sd">        :param weights:    The weight for each cell. Default is one.</span>
<span class="sd">        :type weights:     :py:class:`~.UniformGridData` or NumPy array of same shape or None.</span>
<span class="sd">        :param relative:   Whether fractions refer to relative or absolute count.</span>
<span class="sd">        :type relative:    bool</span>
<span class="sd">        :param min_value: Lower bound of data to consider. Default is data range.</span>
<span class="sd">        :type min_value: float or None</span>
<span class="sd">        :param max_value: Upper bound of data to consider. Default is data range.</span>
<span class="sd">        :type max_value: float or None</span>
<span class="sd">        :param num_bins:      Number of bins to create.</span>
<span class="sd">        :type num_bins:       integer &gt; 1</span>

<span class="sd">        :returns: Data values corresponding to the given fractions.</span>
<span class="sd">        :rtype:   1D NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Function from Wolfgang Kastaun&#39;s PostCactus</span>

        <span class="n">hist_values</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
            <span class="n">min_value</span><span class="o">=</span><span class="n">min_value</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">max_value</span><span class="p">,</span>
            <span class="n">num_bins</span><span class="o">=</span><span class="n">num_bins</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">hist_cumulative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hist_values</span><span class="p">)</span>

        <span class="c1"># So that the last element is 1</span>
        <span class="k">if</span> <span class="n">relative</span><span class="p">:</span>
            <span class="c1"># We need to make sure that the everything is float here,</span>
            <span class="c1"># otherwise NumPy complains</span>
            <span class="n">hist_cumulative</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">hist_cumulative</span>
            <span class="n">hist_cumulative</span> <span class="o">/=</span> <span class="n">hist_cumulative</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># We remove the first point because all the data is larger than that.</span>
        <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># So that we can use it as an array</span>
        <span class="n">fractions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fractions</span><span class="p">)</span>

        <span class="c1"># We must make sure that fractions is not larger than the amount of data</span>
        <span class="c1"># (or of 1, in the case of normalized histogram). If input fraction is</span>
        <span class="c1"># larger than 1, the output must be 100 % of the data anyways.</span>
        <span class="c1">#</span>
        <span class="c1"># We make sure that this is at least 1d so that we can loop over it</span>
        <span class="n">capped_fractions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">hist_cumulative</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fractions</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Here we return the first element of the array bin edges that is larger</span>
        <span class="c1"># than each element in capped_fractions</span>
        <span class="n">percentiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">hist_cumulative</span> <span class="o">&gt;=</span> <span class="n">f</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">capped_fractions</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">percentiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">percentiles</span></div>

<div class="viewcode-block" id="UniformGridData.mask_applied"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.mask_applied">[docs]</a>    <span class="k">def</span> <span class="nf">mask_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ignore_existing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.UniformGridData` with given mask applied to the</span>
<span class="sd">        data.</span>

<span class="sd">        If a previous mask already exists, the new mask will be added on top,</span>
<span class="sd">        unless ``ignore_existing`` is True.</span>

<span class="sd">        :param mask: Array of booleans that identify where the data is invalid.</span>
<span class="sd">                     This can be obtained with the method :py:meth:`~.mask`.</span>
<span class="sd">        :type mask: NumPy array</span>

<span class="sd">        :param ignore_existing: If True, overwrite any previously existing mask.</span>
<span class="sd">        :type ignore_existing: bool</span>

<span class="sd">        :returns: New grid data with mask applied.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_existing</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mask_or</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">))</span></div>

<div class="viewcode-block" id="UniformGridData.mask_apply"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.mask_apply">[docs]</a>    <span class="k">def</span> <span class="nf">mask_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ignore_existing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the given mask.</span>

<span class="sd">        If a previous mask already exists, the new mask will be added on top,</span>
<span class="sd">        unless ``ignore_existing`` is True.</span>

<span class="sd">        :param mask: Array of booleans that identify where the data is invalid.</span>
<span class="sd">                     This can be obtained with the method :py:meth:`~.mask`.</span>
<span class="sd">        :type mask: NumPy array</span>

<span class="sd">        :param ignore_existing: If True, overwrite any previously existing mask.</span>
<span class="sd">        :type ignore_existing: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask_applied</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ignore_existing</span><span class="o">=</span><span class="n">ignore_existing</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.partial_differentiated"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.partial_differentiated">[docs]</a>    <span class="k">def</span> <span class="nf">partial_differentiated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :py:class:`~.UniformGridData` that is the numerical</span>
<span class="sd">        order-differentiation of the present grid_data along a given direction.</span>
<span class="sd">        (``order`` = number of derivatives, ie ``order=2`` is second derivative)</span>

<span class="sd">        The derivative is calculated as centered differencing in the interior</span>
<span class="sd">        and one-sided derivatives at the boundaries. Higher orders are computed</span>
<span class="sd">        applying the same rule recursively.</span>

<span class="sd">        The output has the same shape of ``self``.</span>

<span class="sd">        :param order: Order of derivative (e.g. 2 = second derivative).</span>
<span class="sd">        :type order: int</span>
<span class="sd">        :param direction: Direction of the partial derivative.</span>
<span class="sd">        :type direction: int</span>

<span class="sd">        :returns:  New :py:class:`~.UniformGridData` with derivative.</span>
<span class="sd">        :rtype:    :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Differentiation with masked data is not supported.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">direction</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">direction</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Grid has </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="si">}</span><span class="s2">, dimensions, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2"> is not available&quot;</span>
            <span class="p">)</span>

        <span class="n">ret_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_num_deriv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>

            <span class="n">ret_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span>
                <span class="n">ret_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">direction</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">ret_value</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.gradient"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.gradient">[docs]</a>    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list :py:class:`~.UniformGridData` that are the numerical</span>
<span class="sd">        order-differentiation of the present grid_data along all the directions.</span>
<span class="sd">        (``order`` = number of derivatives, ie ``order=2`` is second derivative)</span>

<span class="sd">        The derivative is calulated as centered differencing in the interior</span>
<span class="sd">        and one-sided derivatives at the boundaries. Higher orders are computed</span>
<span class="sd">        applying the same rule recursively.</span>

<span class="sd">        The output has the same shape of ``self``.</span>

<span class="sd">        :param order: Order of derivative (e.g. 2 = second derivative).</span>
<span class="sd">        :type order: int</span>
<span class="sd">        :param direction: Direction of the partial derivative.</span>
<span class="sd">        :type direction: int</span>
<span class="sd">        :returns:  list of :py:class:`~.UniformGridData` with partial derivative</span>
<span class="sd">                   along the directions.</span>
<span class="sd">        :rtype:    list of :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partial_differentiated</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="UniformGridData.partial_differentiate"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.partial_differentiate">[docs]</a>    <span class="k">def</span> <span class="nf">partial_differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Derive the data with numerical finite difference along a given direction</span>
<span class="sd">        (``order`` = number of derivatives, ie ``order=2`` is second derivative).</span>

<span class="sd">        The derivative is calulated as centered differencing in the interior</span>
<span class="sd">        and one-sided derivatives at the boundaries. Higher orders are computed</span>
<span class="sd">        applying the same rule recursively.</span>

<span class="sd">        The output has the same shape of ``self``.</span>

<span class="sd">        :param order: Order of derivative (e.g. 2 = second derivative).</span>
<span class="sd">        :type order: int</span>
<span class="sd">        :param direction: Direction of the partial derivative.</span>
<span class="sd">        :type direction: int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partial_differentiated</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_coordinates_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">absolute</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return coordinates of a point in data as selected by the given function.</span>

<span class="sd">        :param where: Function that extract a location in the data. The function</span>
<span class="sd">                      has to return a tuple, identifying the point along each of</span>
<span class="sd">                      the dimensions.</span>
<span class="sd">        :type where: callable</span>

<span class="sd">        :param absolute: Whether to take the absolute value of the data.</span>
<span class="sd">        :type absolute: bool</span>

<span class="sd">        :returns: Coordinate of the point identified by ``where``.</span>
<span class="sd">        :rtype: 1D NumPy array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">if</span> <span class="n">absolute</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># coordinates is a list, with the linear coordinates along each</span>
        <span class="c1"># direction</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates_from_grid</span><span class="p">()</span>

        <span class="c1"># We loop over the coordinates and extract the element of position</span>
        <span class="c1"># &quot;pos&quot;. We collect the results in a NumPy array.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">coordinates</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span>
        <span class="p">)</span>

<div class="viewcode-block" id="UniformGridData.coordinates_at_maximum"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.coordinates_at_maximum">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates_at_maximum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the point with maximum value.</span>

<span class="sd">        :returns:  Coordinate at where the value is maximum. If ``absolute``</span>
<span class="sd">                   is True, then the absolute value is first taken.</span>
<span class="sd">        :rtype:    1D NumPy array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates_at</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="n">absolute</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.coordinates_at_minimum"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.coordinates_at_minimum">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates_at_minimum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the point with minimum value.</span>

<span class="sd">        :returns:  Coordinate at where the value is minimum. If ``absolute``</span>
<span class="sd">                   is True, then the absolute value is first taken.</span>
<span class="sd">        :rtype:    1D NumPy array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates_at</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="n">absolute</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_apply_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a unary function to the data.</span>

<span class="sd">        :param function: Unary function.</span>
<span class="sd">        :type function:  callable</span>
<span class="sd">        :returns: Function applied to the data.</span>
<span class="sd">        :rtype:    :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_apply_reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a reduction to the data.</span>

<span class="sd">        :param function: Function to apply to the data.</span>
<span class="sd">        :type function: callable</span>

<span class="sd">        :return: Reduction applied to the data.</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">reduction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_binary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is an abstract function that is used to implement mathematical</span>
<span class="sd">        operations with other :py:class:`~.UniformGridData` (if they have the</span>
<span class="sd">        same grid) or scalars.</span>

<span class="sd">        _apply_binary takes another object that can be of the same type or a</span>
<span class="sd">        scalar, and applies function(self.data, other.data), performing type</span>
<span class="sd">        checking.</span>

<span class="sd">        :param other: Other object.</span>
<span class="sd">        :type other: :py:class:`~.UniformGridData` or scalar</span>
<span class="sd">        :param function: Dyadic function.</span>
<span class="sd">        :type function: callable</span>

<span class="sd">        :returns:  Return value of function when called with ``self`` and ``other``.</span>
<span class="sd">        :rtype:    :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the other object is of the same type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="c1"># Check the the coordinates are the same by checking shape, origin</span>
            <span class="c1"># and dx</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The objects do not have the same grid!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># If it is a number</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># If we are here, it is because we cannot add the two objects</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;I don&#39;t know how to combine these objects&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span>
        <span class="p">)</span>

<div class="viewcode-block" id="UniformGridData.fourier_transform"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.fourier_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fourier_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform the multi-dimensional Fourier transform on the data.</span>

<span class="sd">        We follow NumPy&#39;s conventions, with the exception that we normalize the</span>
<span class="sd">        amplitude with ``dx``.</span>

<span class="sd">        If the signal is complex, we also shift the negative components to be in</span>
<span class="sd">        the negative part of the signal.</span>

<span class="sd">        :returns: Fourier transform.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Fourier transform with masked data is not supported.&quot;</span>
            <span class="p">)</span>

        <span class="n">fft_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
        <span class="c1"># We extract the frequencies along each direction</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">dim</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">):</span>
            <span class="n">fft_data</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="n">lowest_freqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">freqs</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)]</span>
        <span class="n">delta_freqs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">freqs</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="n">UniformGrid</span><span class="p">(</span>
            <span class="n">fft_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="n">lowest_freqs</span><span class="p">,</span>
            <span class="n">dx</span><span class="o">=</span><span class="n">delta_freqs</span><span class="p">,</span>
            <span class="n">ref_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span>
            <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">,</span>
            <span class="n">num_ghost</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="n">iteration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">grid</span><span class="p">,</span> <span class="n">fft_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.to_GridSeries"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.to_GridSeries">[docs]</a>    <span class="k">def</span> <span class="nf">to_GridSeries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :py:class:`~.GridSeries` (if the data is one-dimensional).</span>

<span class="sd">        When the data is one dimensional, sometimes it is more convenient to</span>
<span class="sd">        treat it a series instead of grid data. This class is uses the same</span>
<span class="sd">        infrastructure as :py:class:`~.TimeSeries` and</span>
<span class="sd">        :py:class:`~.FrequencySeries` and has more or less the same features.</span>

<span class="sd">        :returns: Data as a Series.</span>
<span class="sd">        :rtype: :py:class:`~.GridSeries`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only 1D data can be transformed into a Series&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">GridSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates_from_grid</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="HierarchicalGridData"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData">[docs]</a><span class="k">class</span> <span class="nc">HierarchicalGridData</span><span class="p">(</span><span class="n">BaseNumerical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents data defined on mesh-refined grids, consisting of one or more</span>
<span class="sd">    regular datasets with different grid spacings.</span>

<span class="sd">    All the arithmetic operations and binary operators are defined for this</span>
<span class="sd">    class, as well as interpolation and resampling.</span>

<span class="sd">    Upon initialization, we try to merge together all the components (output</span>
<span class="sd">    from different MPI processes), so there is one :py:class:`~.UniformGridData`</span>
<span class="sd">    per refinement level. In case of grids with more than one center of</span>
<span class="sd">    refinement, this is currently not possible, so we keep all the components</span>
<span class="sd">    around. In this, ghost zone information may be discarded.</span>

<span class="sd">    :ivar grid_data_dict: Mapping between refinement levels and components at</span>
<span class="sd">                          that refinement level.</span>
<span class="sd">    :type grid_data_dict: dict of :py:class:`~.UniformGridData`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uniform_grid_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        Here we try to merge the different components, if we can.</span>

<span class="sd">        :param uniform_grid_data: List of regular datasets.</span>
<span class="sd">        :type uniform_grid_data:  list of :py:class:`~.UniformGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">uniform_grid_data</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is built with list &quot;</span>
                <span class="s2">&quot;of UniformGridData&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniform_grid_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot create an empty </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">UniformGridData</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">uniform_grid_data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> requires a list of UniformGridData&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="n">d</span><span class="o">.</span><span class="n">num_dimensions</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">uniform_grid_data</span><span class="p">})</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimensionality mismatch&quot;</span><span class="p">)</span>

        <span class="c1"># Let&#39;s sort as increasing refinement level and component</span>
        <span class="n">uniform_grid_data_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">uniform_grid_data</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">component</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">components</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Organize the components and create a copy. In creating a copy we</span>
        <span class="c1"># declare ownership of the UniformGridData</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">uniform_grid_data_sorted</span><span class="p">:</span>
            <span class="n">components</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">ref_level</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_merge_components</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">comps</span> <span class="ow">in</span> <span class="n">components</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># Map between coordinates and which component to use when computing</span>
        <span class="c1"># values. self._component_mapping is a function that takes a point and</span>
        <span class="c1"># returns the associated component. The reason this is an attribute is</span>
        <span class="c1"># to save it and avoid re-computing the mapping all the time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_component_mapping</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_check_ref_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if all the grids have dx that is an integer multiple of dx_finest.</span>

<span class="sd">        :returns: Whether dx/dx_finest if integer for all the components.</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">def</span> <span class="nf">is_integer</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">comp_ref_factor</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># ref_factors is a dictionary that has as keys the number of refinement</span>
        <span class="c1"># level and as values a NumPy array with the refinement factor for that</span>
        <span class="c1"># level. We will loop over all the components and use this dictionary to</span>
        <span class="c1"># check if we have variable refinement factors across levels.</span>
        <span class="n">ref_factors</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Next, we loop over all the components and check if their dx is an</span>
        <span class="c1"># integral multiple of dx_finest</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">:</span>

            <span class="n">ref_level</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">ref_level</span>
            <span class="n">comp_ref_factor</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">dx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">finest_dx</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">comp_ref_factor</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># On a given refinement level, the refinement factors have to be</span>
            <span class="c1"># the same because HierarchicalGridData works only with grids</span>
            <span class="c1"># with same dx at a given level. So, here can simply overwrite</span>
            <span class="c1"># the value that we have.</span>
            <span class="n">ref_factors</span><span class="p">[</span><span class="n">ref_level</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp_ref_factor</span>

        <span class="c1"># Now we loop over the refinement factors to check that they are always</span>
        <span class="c1"># the same. We compute what is the refinement factor that we expect</span>
        <span class="c1"># looking at the coarsest and finest levels, then we check that this</span>
        <span class="c1"># is indeed the one we observe on each level.</span>
        <span class="c1">#</span>
        <span class="c1"># Consider the case we have three levels.</span>
        <span class="c1"># Level 3 (finest) has dx = [2, 2]</span>
        <span class="c1"># Level 2 has dx = [6, 6]</span>
        <span class="c1"># Level 1 has dx = [18, 18]</span>
        <span class="c1">#</span>
        <span class="c1"># Here what we do is we take dx_coarse / dx_fine = [9, 9], and take the</span>
        <span class="c1"># power of 1/(3 - 1) = 1/2 = sqrt, so we obtain [3, 3]. This is how the</span>
        <span class="c1"># dx grows on each level.</span>
        <span class="n">expected_base_ref_factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">ref_factors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_coarsest_level</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_finest_level</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_coarsest_level</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">ref_factor</span> <span class="ow">in</span> <span class="n">ref_factors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Then, we find on each level what is the expected refinement factor</span>
            <span class="c1"># given the base one. For the previous example we would have:</span>
            <span class="c1"># Level 1: [3, 3] ** (3 - 1) = [9, 9]</span>
            <span class="c1"># Level 2: [3, 3] ** (3 - 2) = [3, 3]</span>
            <span class="c1"># Level 3: [3, 3] ** (3 - 3) = [1, 1]</span>
            <span class="n">expected_ref_factor</span> <span class="o">=</span> <span class="n">expected_base_ref_factor</span> <span class="o">**</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_finest_level</span> <span class="o">-</span> <span class="n">ref_level</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ref_factor</span><span class="p">,</span> <span class="n">expected_ref_factor</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># All integers and constant</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_compute_component_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scan the grid structure and prepare a map between points and components.</span>

<span class="sd">        :returns: Function that maps a point to the UniformGridData at highest</span>
<span class="sd">                  resolution that contains that point.</span>
<span class="sd">        :rtype: callable</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If refinement factors are not nice powers, then we cannot use this</span>
        <span class="c1"># method.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_ref_factors</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># NOTE: (GB) This algorithm is from PostCactus (in</span>
        <span class="c1"># grid_data.BrickCoords). I don&#39;t understand it, but it works. All the</span>
        <span class="c1"># comments are mine, and maybe they don&#39;t make any sense.</span>

        <span class="c1"># We can do this operation only if the various grids have dx that is all</span>
        <span class="c1"># multiple of dx_finest. This is checked by_check_ref_factors.</span>
        <span class="c1">#</span>
        <span class="c1"># First, we define a dx that is half a minimum cell and we are going to</span>
        <span class="c1"># use the lowest component number among the highest refinement level as</span>
        <span class="c1"># our &quot;coordinate system&quot;. We call this new coordinate system the</span>
        <span class="c1"># &quot;tilde&quot; coordinate system. In the tilde coordinate system, the all the</span>
        <span class="c1"># cells have integer coordinate.</span>

        <span class="c1"># Create local copies of some variables, so that we don&#39;t have to</span>
        <span class="c1"># compute them multiple times. We also sort in the opposite order, with</span>
        <span class="c1"># highest resolution first</span>
        <span class="n">all_components</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">,</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">comp</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">comp</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">component</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="n">half_dx_finest</span> <span class="o">=</span> <span class="n">all_components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">all_components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x0</span>

        <span class="k">def</span> <span class="nf">to_tilde</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Convert a coordinate to tilde coordinate system (based on the first</span>
<span class="sd">            finest component).</span>

<span class="sd">            :param x: Coordinate.</span>
<span class="sd">            :type x: NumPy array</span>
<span class="sd">            :returns: Index in the coordinate system based on the first finest</span>
<span class="sd">                      component.</span>
<span class="sd">            :rtype: NumPy array</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">origin</span><span class="p">)</span> <span class="o">/</span> <span class="n">half_dx_finest</span><span class="p">)</span>

        <span class="c1"># Now we find where all the origins of the components fall in this new</span>
        <span class="c1"># coordinate system</span>
        <span class="n">origins_tilde</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">to_tilde</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">lowest_vertex</span><span class="p">)</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">all_components</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">corners_tilde</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">to_tilde</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">highest_vertex</span><span class="p">)</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">all_components</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># origins and corners tilde are NumPy arrays with N D-dimensional</span>
        <span class="c1"># elements. N is the number of components, D is the dimensionality of</span>
        <span class="c1"># the grid.</span>

        <span class="c1"># Next, we group together all the origins and consider only the unique</span>
        <span class="c1"># points along each direction. unique_origins_tilde</span>
        <span class="c1"># (unique_corners_tilde) is a D-dimensional list</span>
        <span class="n">unique_origins_tilde</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span> <span class="k">for</span> <span class="n">orig</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">origins_tilde</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">unique_corners_tilde</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">corn</span><span class="p">)</span> <span class="k">for</span> <span class="n">corn</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">corners_tilde</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Now we collect all the boundaries (origins and corners)</span>
        <span class="n">boundaries_tilde</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">sorted</span><span class="p">(</span><span class="n">orig</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">corn</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">orig</span><span class="p">,</span> <span class="n">corn</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unique_origins_tilde</span><span class="p">,</span> <span class="n">unique_corners_tilde</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">def</span> <span class="nf">x_tilde_to_component</span><span class="p">(</span><span class="n">x_tilde</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Given a point in the tilde coordinates, return the indices of</span>
<span class="sd">            boundaries_tilde that contain that point</span>

<span class="sd">            :returns: Multi-index (one index for each direction) that identifies</span>
<span class="sd">                      the block in ``boundaries_tilde`` that contains the</span>
<span class="sd">                      point.</span>
<span class="sd">            :rtype: tuple</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">bisect_right</span><span class="p">(</span><span class="n">boundary_dim</span><span class="p">,</span> <span class="n">x_tilde_dim</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">boundary_dim</span><span class="p">,</span> <span class="n">x_tilde_dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">boundaries_tilde</span><span class="p">,</span> <span class="n">x_tilde</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Now we go back and find where all the origins and corners are</span>
        <span class="n">boundary_origins_tilde</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">x_tilde_to_component</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span> <span class="k">for</span> <span class="n">orig</span> <span class="ow">in</span> <span class="n">origins_tilde</span>
        <span class="p">]</span>
        <span class="n">boundary_corners_tilde</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">x_tilde_to_component</span><span class="p">(</span><span class="n">corn</span><span class="p">)</span> <span class="k">for</span> <span class="n">corn</span> <span class="ow">in</span> <span class="n">corners_tilde</span>
        <span class="p">]</span>

        <span class="c1"># And the last step is to find what is the finest refinement level</span>
        <span class="c1"># available on each block</span>

        <span class="n">finest_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">boundaries_tilde</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">component_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">boundary_origins_tilde</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">slicer</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">slice</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">corn</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">orig</span><span class="p">,</span> <span class="n">corn</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">boundary_origins_tilde</span><span class="p">[</span><span class="n">component_index</span><span class="p">],</span>
                    <span class="n">boundary_corners_tilde</span><span class="p">[</span><span class="n">component_index</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">]</span>
            <span class="n">finest_map</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slicer</span><span class="p">)]</span> <span class="o">=</span> <span class="n">component_index</span>

        <span class="k">def</span> <span class="nf">get_component</span><span class="p">(</span><span class="n">coordinate</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Map a coordinate to the component that contains it.&quot;&quot;&quot;</span>

            <span class="c1"># This is like to_tilde, but we floor instead of rounding.</span>
            <span class="c1"># God knows why.</span>
            <span class="n">x_tilde</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">coordinate</span> <span class="o">-</span> <span class="n">origin</span><span class="p">)</span> <span class="o">/</span> <span class="n">half_dx_finest</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                <span class="p">((</span><span class="n">point_dim</span> <span class="o">&lt;</span> <span class="n">border_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">point_dim</span> <span class="o">&gt;=</span> <span class="n">border_dim</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">point_dim</span><span class="p">,</span> <span class="n">border_dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_tilde</span><span class="p">,</span> <span class="n">boundaries_tilde</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">coordinate</span><span class="si">}</span><span class="s2"> outside the grid&quot;</span><span class="p">)</span>

            <span class="c1"># The list comprehension is over the various dimensions</span>
            <span class="n">component_index</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">bisect_right</span><span class="p">(</span><span class="n">boundary_dim</span><span class="p">,</span> <span class="n">x_tilde_dim</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">boundary_dim</span><span class="p">,</span> <span class="n">x_tilde_dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">boundaries_tilde</span><span class="p">,</span> <span class="n">x_tilde</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">all_components</span><span class="p">[</span><span class="n">finest_map</span><span class="p">[</span><span class="n">component_index</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">get_component</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_fill_grid_with_components</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">components</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a grid, try to fill it with the components, return eturning a</span>
<span class="sd">        :py:class:`~.UniformGridData` and the indices that actually were used in</span>
<span class="sd">        filling the grid.</span>

<span class="sd">        This happens by iterating over the components and copying data to the</span>
<span class="sd">        output grid, recording what points were filled. We also return the indices</span>
<span class="sd">        of the points that were filled.</span>

<span class="sd">        :param grid: Grid to fill.</span>
<span class="sd">        :type grid: :py:class:`~.UniformGrid`</span>
<span class="sd">        :param components: Components to fill the grid.</span>
<span class="sd">        :type components: list of :py:class:`~.UniformGridData`</span>

<span class="sd">        :returns: Merged components and indices used to merge the components.</span>
<span class="sd">        :rtype: tuple of :py:class:`~.UniformGridData` and numpy array</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># For filling the data, we prepare the array first, and we fill it with</span>
        <span class="c1"># the single components. We fill a second array which we use to keep</span>
        <span class="c1"># track of what indices have been filled with the input data.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">indices_used</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">components</span>
        <span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
            <span class="c1"># We find the index corresponding to x0 and x1 of the component</span>
            <span class="n">index_x0</span> <span class="o">=</span> <span class="p">((</span><span class="n">comp</span><span class="o">.</span><span class="n">x0</span> <span class="o">-</span> <span class="n">grid</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="n">grid</span><span class="o">.</span><span class="n">dx</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">index_x1</span> <span class="o">=</span> <span class="n">index_x0</span> <span class="o">+</span> <span class="n">comp</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">slicer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="nb">slice</span><span class="p">(</span><span class="n">index_j0</span><span class="p">,</span> <span class="n">index_j1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">index_j0</span><span class="p">,</span> <span class="n">index_j1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index_x0</span><span class="p">,</span> <span class="n">index_x1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">data</span>
            <span class="n">indices_used</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">UniformGridData</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">data</span><span class="p">),</span> <span class="n">indices_used</span>

    <span class="k">def</span> <span class="nf">_try_merge_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">components</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to merge a list of :py:class:`~.UniformGridData` instances into one,</span>
<span class="sd">        assuming they all have the same grid spacing and filling a regular grid</span>
<span class="sd">        completely.</span>

<span class="sd">        If the assumption is not verified, and some blank spaces are found, then</span>
<span class="sd">        it returns the input untouched. This happens in the case that there are</span>
<span class="sd">        multiple refinement centers, or if there are missing components.</span>

<span class="sd">        This function always returns a list, even when the components are merged.</span>
<span class="sd">        In that case, the return value is a ``[merged]``, where ``merged`` is a</span>
<span class="sd">        :py:class:`~.UniformGridData`.</span>

<span class="sd">        :param components: List of components.</span>
<span class="sd">        :type components: list of :py:class:`~.UniformGridData`</span>

<span class="sd">        :returns: List of components, or list with one single element, the merged</span>
<span class="sd">                  components.</span>
<span class="sd">        :rtype: list of :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ghost_zones_removed</span><span class="p">()]</span>

        <span class="c1"># TODO: Instead of throwing away the ghost zones, we should check them</span>

        <span class="c1"># We remove all the ghost zones so that we can arrange all the grids</span>
        <span class="c1"># one next to the other without having to worry about the overlapping</span>
        <span class="c1"># regions</span>
        <span class="n">components_no_ghosts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">ghost_zones_removed</span><span class="p">()</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">components</span>
        <span class="p">]</span>

        <span class="c1"># For convenience, we also order the components from the one with the</span>
        <span class="c1"># smallest x0 to the largest, so that we can easily find the</span>
        <span class="c1"># coordinates.</span>
        <span class="c1">#</span>
        <span class="c1"># We have to transform x.x0 in tuple because we cannot compare NumPy</span>
        <span class="c1"># arrays directly for sorting.</span>
        <span class="n">components_no_ghosts</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">x0</span><span class="p">))</span>

        <span class="c1"># Next, we prepare the global grid</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">gdu</span><span class="o">.</span><span class="n">merge_uniform_grids</span><span class="p">(</span>
            <span class="p">[</span><span class="n">comp</span><span class="o">.</span><span class="n">grid</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">components_no_ghosts</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">merged_grid_data</span><span class="p">,</span> <span class="n">indices_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_grid_with_components</span><span class="p">(</span>
            <span class="n">grid</span><span class="p">,</span> <span class="n">components_no_ghosts</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">indices_used</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">merged_grid_data</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">components</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of components at the given refinement level.</span>

<span class="sd">        You can also consider using :py:meth:`~.get_level`, which returns a</span>
<span class="sd">        single :py:class:`~.UniformGridData` if there&#39;s only one component at</span>
<span class="sd">        that level (otherwise error).</span>

<span class="sd">        :param key: Refinement level.</span>
<span class="sd">        :type key: int</span>

<span class="sd">        :returns: List of components at a given refinement level.</span>
<span class="sd">        :rvalue: list of :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

<div class="viewcode-block" id="HierarchicalGridData.get_level"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.get_level">[docs]</a>    <span class="k">def</span> <span class="nf">get_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the data at a given refinement level.</span>

<span class="sd">        :param ref_level: Number of refinement level.</span>
<span class="sd">        :type ref_level: int</span>

<span class="sd">        :returns: Data at given refinement level.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ref_level</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Level </span><span class="si">{</span><span class="n">ref_level</span><span class="si">}</span><span class="s2"> not available&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ref_level</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Level </span><span class="si">{</span><span class="n">ref_level</span><span class="si">}</span><span class="s2"> has multiple patches&quot;</span>
                <span class="s2">&quot; get_level works only when there is one&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">ref_level</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="HierarchicalGridData.iter_from_finest"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.iter_from_finest">[docs]</a>    <span class="k">def</span> <span class="nf">iter_from_finest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterator over the components, sorted by refinement level, from the finest to</span>
<span class="sd">        the coarsest.</span>

<span class="sd">        :returns: Refinement level number, component index, and data.</span>
<span class="sd">        :rtype: generator of tuples (int, int, :py:class:`~.UniformGridData`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">comp_index</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">comp_index</span><span class="p">,</span> <span class="n">comp</span></div>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate across all the refinement levels and components from the coarsest</span>
<span class="sd">        to the finest.</span>

<span class="sd">        :returns: Refinement level number, component index, and data.</span>
<span class="sd">        :rtype: tuple (int, int, :py:class:`~.UniformGridData`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">comp_index</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">comp_index</span><span class="p">,</span> <span class="n">comp</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">refinement_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list with the refinement levels available.</span>

<span class="sd">        :returns: List of refinement levels available.</span>
<span class="sd">        :rtype: list of ints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list with all the components.</span>

<span class="sd">        This is useful to create a new :py:class:`~.HierarchicalGridData`</span>
<span class="sd">        from ``self``.</span>

<span class="sd">        :returns: List of all the components.</span>
<span class="sd">        :rtype: list of :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: (PERFORMANCE) Optimize method called often</span>
        <span class="c1">#</span>
        <span class="c1"># This method is used every time we loop over all the components. Hence,</span>
        <span class="c1"># it is called by several other methods. It is important to optimize it</span>
        <span class="c1"># further to improve overall performance.</span>

        <span class="n">all_components</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comps</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">all_components</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_components</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_finest_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of the finest refinement level.</span>

<span class="sd">        :returns: Index of the finest level.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">finest_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the finest level, if it is a single grid.</span>

<span class="sd">        :returns: Finest level.</span>
<span class="sd">        :rtype: :py:class:`~UniformGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_level</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_finest_level</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_refinement_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of the finest refinement level.</span>

<span class="sd">        Alias for :py:meth:`~.num_finest_level`.</span>

<span class="sd">        :returns: Index of the finest level.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_finest_level</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_coarsest_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of the coarsest refinement level.</span>

<span class="sd">        :returns: Index of the coarsest level.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coarsest_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the coarsest level, if it is a single grid.</span>

<span class="sd">        :returns: Coarsest level.</span>
<span class="sd">        :rtype: :py:class:`~UniformGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_level</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_coarsest_level</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the first component of the coarsest refinement level.</span>

<span class="sd">        :returns: First component of the coarsest level.</span>
<span class="sd">        :rtype: `:py:class:~UniformGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_coarsest_level</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_a_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the a component of the hierarchy.</span>

<span class="sd">        It is useful to understand various properties that are shared</span>
<span class="sd">        by all the components, e.g. the dtype.</span>

<span class="sd">        Using this method is faster than :py:func:`~.first_component`.</span>

<span class="sd">        :returns: First component of the coarsest level.</span>
<span class="sd">        :rtype: `:py:class:~UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a_component</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of components per each refinement level.</span>

<span class="sd">        For example, if data has three levels, with 1 component in the first, 2</span>
<span class="sd">        in the second, and three in the fifth, shape will be {1: 1, 2: 2, 5: 3}</span>

<span class="sd">        This method is useful for quick high level comparison between two</span>
<span class="sd">        :py:class:`~.HierachicalGridData`.</span>

<span class="sd">        :returns: Dictionary with keys the refinement level numbers and values the</span>
<span class="sd">                  number of components at that level.</span>
<span class="sd">        :rtype: dictionary</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">ref_level</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Origin of the coarsest grid, if it is a single component.</span>

<span class="sd">        :returns: Origin of the coarsest grid, if it is a single component.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We have multiple patches</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_coarsest_level</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Data does not have a well defined x0&quot;</span>
                <span class="s2">&quot; (there are multiple patches)&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_component</span><span class="o">.</span><span class="n">x0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Corner of the coarsest grid, if it is a single component.</span>

<span class="sd">        :returns: Corner of the coarsest grid, if it is a single component.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We have multiple patches</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_coarsest_level</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Data does not have a well defined x1&quot;</span>
                <span class="s2">&quot; (there are multiple patches)&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_component</span><span class="o">.</span><span class="n">x1</span>

<div class="viewcode-block" id="HierarchicalGridData.dx_at_level"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.dx_at_level">[docs]</a>    <span class="k">def</span> <span class="nf">dx_at_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the grid spacing at the specified refinement level.</span>

<span class="sd">        :param level: Refinement level number.</span>
<span class="sd">        :type level: int</span>
<span class="sd">        :returns: Spacing at the given refinement level.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">level</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coarsest_dx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the grid spacing of the coarsest level.</span>

<span class="sd">        :returns:  Grid spacing of the coarsest level.</span>
<span class="sd">        :rtype:   1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx_at_level</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_coarsest_level</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">finest_dx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the grid spacing of the finest level.</span>

<span class="sd">        :returns:  Grid spacing of the finest level.</span>
<span class="sd">        :rtype:   1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx_at_level</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_finest_level</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of dimensions.</span>

<span class="sd">        :returns:  Number of dimensions.</span>
<span class="sd">        :rtype:   int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a_component</span><span class="o">.</span><span class="n">num_dimensions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_extended_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of dimensions with more than one cell.</span>

<span class="sd">        :returns:  Number of dimensions with more than one gridpoint.</span>
<span class="sd">        :rtype:   int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a_component</span><span class="o">.</span><span class="n">num_extended_dimensions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The time of the coarsest refinement level.</span>

<span class="sd">        :returns:  Time of the coarsest refinement level.</span>
<span class="sd">        :rtype:   float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_component</span><span class="o">.</span><span class="n">time</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The iteration of the coarsest refinement level.</span>

<span class="sd">        :returns:  Iteration number of the coarsest refinement level.</span>
<span class="sd">        :rtype:   int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_component</span><span class="o">.</span><span class="n">iteration</span>

<div class="viewcode-block" id="HierarchicalGridData.is_complex"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.is_complex">[docs]</a>    <span class="k">def</span> <span class="nf">is_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the data is complex.</span>

<span class="sd">        :returns:  True if the data is complex, false if it is not.</span>
<span class="sd">        :rtype:   bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">is_complex</span><span class="p">()</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return where the data is valid (according to the mask).</span>

<span class="sd">        :returns: List of arrays of True/False, one per component</span>
<span class="sd">                  in the same order as :py:meth:`~.all_components`.</span>
<span class="sd">        :rtype: list of arrays of bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">comp</span><span class="o">.</span><span class="n">mask</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">]</span>

<div class="viewcode-block" id="HierarchicalGridData.is_masked"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.is_masked">[docs]</a>    <span class="k">def</span> <span class="nf">is_masked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the data is masked.</span>

<span class="sd">        :returns:  True if the data is masked, false if it is not.</span>
<span class="sd">        :rtype:   bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">is_masked</span><span class="p">()</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.copy"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a deep copy.</span>

<span class="sd">        :returns:  Deep copy of the :py:class:`~.HierarchicalGridData`.</span>
<span class="sd">        :rtype:    :py:class:`~.HierarchicalGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.mask_applied"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.mask_applied">[docs]</a>    <span class="k">def</span> <span class="nf">mask_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ignore_existing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new grid data with given mask applied to the data.</span>

<span class="sd">        If a previous mask already exists, the new mask will be added on top,</span>
<span class="sd">        unless ``ignore_existing`` is True.</span>

<span class="sd">        :param mask: List of arrays of booleans (one per component) that identify</span>
<span class="sd">                     where the data is invalid.</span>
<span class="sd">                     This can be obtained with the method :py:meth:`~.mask`.</span>
<span class="sd">        :type mask: list of NumPy array</span>

<span class="sd">        :param ignore_existing: If True, overwrite any previously existing mask.</span>
<span class="sd">        :type ignore_existing: bool</span>

<span class="sd">        :returns: New grid data with mask applied.</span>
<span class="sd">        :rtype: :py:class:`~.HierarchicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
            <span class="p">[</span>
                <span class="n">comp</span><span class="o">.</span><span class="n">mask_applied</span><span class="p">(</span><span class="n">mask_comp</span><span class="p">,</span> <span class="n">ignore_existing</span><span class="o">=</span><span class="n">ignore_existing</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">comp</span><span class="p">,</span> <span class="n">mask_comp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.mask_apply"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.mask_apply">[docs]</a>    <span class="k">def</span> <span class="nf">mask_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ignore_existing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply given mask.</span>

<span class="sd">        If a previous mask already exists, the new mask will be added on top,</span>
<span class="sd">        unless ``ignore_existing`` is True.</span>

<span class="sd">        :param mask: List of arrays of booleans (one per component) that identify</span>
<span class="sd">                     where the data is invalid.</span>
<span class="sd">                     This can be obtained with the method :py:meth:`~.mask`.</span>
<span class="sd">        :type mask: list of NumPy array</span>

<span class="sd">        :param ignore_existing: If True, overwrite any previously existing mask.</span>
<span class="sd">        :type ignore_existing: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask_applied</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">ignore_existing</span><span class="o">=</span><span class="n">ignore_existing</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check for equality.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HierarchicalGridData</span><span class="p">)</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">all_components</span>

    <span class="k">def</span> <span class="nf">_finest_component_at_point_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the component of the most refined level that contains the given</span>
<span class="sd">        coordinate assuming a valid input coordinate using the component mapping.</span>

<span class="sd">        This routine works only with grids in which the spacings are</span>
<span class="sd">        commensurable.</span>

<span class="sd">        :param coordinate: Point.</span>
<span class="sd">        :type coordinate: tuple or NumPy array with the same dimension</span>

<span class="sd">        :returns: Component with highest resolution at point</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_component_mapping</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_finest_component_at_point_general</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the component of the most refined level that contains the given</span>
<span class="sd">        coordinate assuming a valid input coordinate.</span>

<span class="sd">        This routine works with all the grids.</span>

<span class="sd">        :param coordinate: Point.</span>
<span class="sd">        :type coordinate: tuple or NumPy array with the same dimension</span>

<span class="sd">        :returns: Component with highest resolution at point</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We walk from the finest level to the coarsest. If we find the point,</span>
        <span class="c1"># re return it. If we find nothing, we raise error.</span>
        <span class="k">for</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">grid_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_from_finest</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">coordinate</span> <span class="ow">in</span> <span class="n">grid_data</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">ref_level</span><span class="p">][</span><span class="n">comp</span><span class="p">]</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">coordinate</span><span class="si">}</span><span class="s2"> outside the grid&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="HierarchicalGridData.finest_component_at_point"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.finest_component_at_point">[docs]</a>    <span class="k">def</span> <span class="nf">finest_component_at_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">,</span> <span class="n">no_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number and the component index of the most</span>
<span class="sd">        refined level that contains the given coordinate.</span>

<span class="sd">        :param coordinate: Point.</span>
<span class="sd">        :type coordinate: tuple or NumPy array with the same dimension</span>
<span class="sd">        :param no_checks: Do not perform sanity checks on the input (for</span>
<span class="sd">                          speed).</span>
<span class="sd">        :type no_checks: bool</span>

<span class="sd">        :returns: Component with highest resolution at point</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">no_checks</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">coordinate</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">coordinate</span><span class="si">}</span><span class="s2"> is not a valid point&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The input point has dimension </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; but the data has dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># If we don&#39;t have self._component_mapping, we should try to compute it.</span>
        <span class="c1"># If we get back None, it means that it cannot be computed for this</span>
        <span class="c1"># grid. Here it is the perfectly place where to use the walrus operator.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_component_mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_component_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_component_mapping</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_component_mapping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">finder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finest_component_at_point_mapping</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">finder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finest_component_at_point_general</span>

        <span class="c1"># finder is the function that returns the component given the coordinate</span>
        <span class="k">return</span> <span class="n">finder</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.evaluate_with_spline"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.evaluate_with_spline">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_with_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the spline on the points ``x``.</span>

<span class="sd">        Values outside the interval are set to 0 if ext=1, or a ``ValueError``</span>
<span class="sd">        is raised if ``ext=2``.</span>

<span class="sd">        This method is meant to be used only if you want to use a different</span>
<span class="sd">        ``ext`` for a specific call, otherwise, just use __call__.</span>

<span class="sd">        :param x: Points where to evaluate the data.</span>
<span class="sd">        :type x: 1D NumPy array of float, or :py:class:`~.UniformGrid`</span>

<span class="sd">        :param ext: How to deal values outside the bounaries. Values outside</span>
<span class="sd">                    the interval are set to 0 if ``ext=1``,</span>
<span class="sd">                    or an error is raised if ``ext=2``.</span>
<span class="sd">        :type ext:  int</span>

<span class="sd">        :returns: Values of the data evaluated on the input ``x``.</span>
<span class="sd">        :rtype:   1D NumPy array or float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">piecewise_constant</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Splines with masked data are not supported.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">UniformGrid</span><span class="p">):</span>
            <span class="c1"># The way we want the coordinates is like as an array with the same</span>
            <span class="c1"># shape of the grid and with values the coordinates (as arrays). This</span>
            <span class="c1"># is similar to as_same_shape, but the coordinates have to be the</span>
            <span class="c1"># value, and not the first index.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">as_same_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># We flatten the array (up to the last dimension) and we save the</span>
        <span class="c1"># original shape, because we are going to reshape it at the end.</span>
        <span class="n">points_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">original_shape</span> <span class="o">=</span> <span class="n">points_arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">points_arr</span> <span class="o">=</span> <span class="n">points_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">points_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># NOTE: The following algorithm is not the fastest but it doesn&#39;t matter</span>
        <span class="c1">#       too much because UniformGridData.evaluate_with_spline dominates</span>
        <span class="c1">#       the execution time.</span>
        <span class="c1">#</span>
        <span class="c1">#       Note also that is it tested by testing finest_component_at_point</span>
        <span class="c1">#       (and not directly)</span>

        <span class="c1"># Next, we organize points depending on the component/refinement level</span>
        <span class="c1"># they belong.</span>
        <span class="c1">#</span>
        <span class="c1"># level_comps is a dictionary with keys the refinement levels and</span>
        <span class="c1"># components for which we have to compute points and for values a list</span>
        <span class="c1"># with the index of the points in points_arr. We need the indices because</span>
        <span class="c1"># we need to put back the values where they were, since we are going to</span>
        <span class="c1"># take bit and pieces of the array.</span>
        <span class="c1">#</span>
        <span class="c1"># Then, we have another mapping level_comps_data that has as keys the</span>
        <span class="c1"># same keys as level_comps, but values the actual component</span>
        <span class="c1"># (UniformGridData) that has to be used for the calculation</span>
        <span class="n">level_comps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">level_comps_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points_arr</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">finest_component_at_point</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">no_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">component</span>
            <span class="n">level_comps</span><span class="o">.</span><span class="n">setdefault</span><span class="p">((</span><span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span><span class="p">),</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">level_comps_data</span><span class="o">.</span><span class="n">setdefault</span><span class="p">((</span><span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span><span class="p">),</span> <span class="n">data</span><span class="p">)</span>

        <span class="c1"># Now, we can evaluate the points using the methods of UniformGridData.</span>
        <span class="c1"># We collect all results in a new array that is initially full of zeros</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points_arr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span><span class="p">),</span> <span class="n">points_indices</span> <span class="ow">in</span> <span class="n">level_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">points_arr</span><span class="p">[</span><span class="n">level_comps</span><span class="p">[</span><span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span><span class="p">]]</span>
            <span class="n">evaluated_points</span> <span class="o">=</span> <span class="n">level_comps_data</span><span class="p">[</span>
                <span class="p">(</span><span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span><span class="p">)</span>
            <span class="p">]</span><span class="o">.</span><span class="n">evaluate_with_spline</span><span class="p">(</span>
                <span class="n">points</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="n">piecewise_constant</span>
            <span class="p">)</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">points_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">evaluated_points</span>

        <span class="c1"># Finally, we have to reshape the array to the correct form.</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_with_spline</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="HierarchicalGridData.to_UniformGridData_from_grid"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.to_UniformGridData_from_grid">[docs]</a>    <span class="k">def</span> <span class="nf">to_UniformGridData_from_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine the refinement levels into a :py:class:`~.UniformGridData`</span>
<span class="sd">        on the specified :py:class:`~.UniformGrid`.</span>

<span class="sd">        If ``resample`` is True, the data is resampled with multilinear</span>
<span class="sd">        interpolation.</span>

<span class="sd">        :param grid: Grid onto which to resample the data.</span>
<span class="sd">        :type grid: :py:class:`~.UniformGrid`.</span>
<span class="sd">        :param resample: If True, resample the data with multilinear interpolation,</span>
<span class="sd">                         otherwise, use nearest neighbors.</span>
<span class="sd">        :type resample: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">UniformGridData</span><span class="p">(</span>
            <span class="n">grid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_with_spline</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="n">resample</span><span class="p">)),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.to_UniformGridData"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.to_UniformGridData">[docs]</a>    <span class="k">def</span> <span class="nf">to_UniformGridData</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine the refinement levels into a :py:class:`~.UniformGridData` specified</span>
<span class="sd">        by the given ``shape``, ``x0``, and ``dx`` or ``x1``.</span>

<span class="sd">        Additional arguments are sent to the constructor of</span>
<span class="sd">        :py:class:`~.UniformGrid`.</span>

<span class="sd">        If ``resample`` is True, the data is resampled with multilinear</span>
<span class="sd">        interpolation.</span>

<span class="sd">        :param shape: Number of points across all the dimensions.</span>
<span class="sd">        :type shape: 1d NumPy array</span>
<span class="sd">        :param x0: Origin.</span>
<span class="sd">        :type x0: 1d NumPy array, or None</span>
<span class="sd">        :param x1: Grid corner. If None, it will be inferred.</span>
<span class="sd">        :type x1:  1d NumPy array, or None</span>
<span class="sd">        :param dx: Grid spacing. If None, it will be inferred.</span>
<span class="sd">        :type dx: 1d NumPy array, or None</span>
<span class="sd">        :param resample: If True, resample the data with multilinear interpolation,</span>
<span class="sd">                         otherwise, use nearest neighbors.</span>
<span class="sd">        :type resample: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">UniformGrid</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_UniformGridData_from_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.refinement_levels_merged"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.refinement_levels_merged">[docs]</a>    <span class="k">def</span> <span class="nf">refinement_levels_merged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.UniformGridData` with all the available</span>
<span class="sd">        data combined and resampled to a grid that encompasses all the</span>
<span class="sd">        components and has resolution of the finest refinement level.</span>

<span class="sd">        When ``resample`` is True, data from coarser refinement levels is</span>
<span class="sd">        resampled with multilinear interpolation, otherwise the nearest</span>
<span class="sd">        neighbors are used.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            For most practical purposes, using this function is an overkill.</span>
<span class="sd">            This can be a very expensive operation and require a lot of memory.</span>
<span class="sd">            Prefer :py:meth:`to_UniformGridData` when possible. The only real</span>
<span class="sd">            reasonable application of this function is with small simluations or</span>
<span class="sd">            1D data.</span>

<span class="sd">        :param resample: If True, resample the data with multilinear interpolation,</span>
<span class="sd">                         otherwise, use nearest neighbors.</span>
<span class="sd">        :type resample: bool</span>

<span class="sd">        :returns: New :py:class:`~.UniformGridData` with the resolution of the</span>
<span class="sd">                  finest refinement level.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If we have only one refinement level, with one component, we should</span>
        <span class="c1"># just return that.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_component</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># finest_dx can have zero entries, for which a shape of 1 should</span>
        <span class="c1"># correspond. There can zero entries, we substitute them with -1, so</span>
        <span class="c1"># that we can identify them as negative numbers</span>
        <span class="n">new_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx</span> <span class="k">if</span> <span class="n">dx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">finest_dx</span><span class="p">])</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="n">new_dx</span> <span class="o">+</span> <span class="mf">1.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span> <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new_shape</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_UniformGridData</span><span class="p">(</span>
            <span class="n">new_shape</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span>
            <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dx</span><span class="o">=</span><span class="n">new_dx</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="n">iteration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span>
            <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.merge_refinement_levels"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.merge_refinement_levels">[docs]</a>    <span class="k">def</span> <span class="nf">merge_refinement_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;DEPRECATED.&quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;merge_refinement_levels was renamed to refinement_levels_merged &quot;</span>
            <span class="s2">&quot;and it will be removed in kuibit 1.5.0&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels_merged</span><span class="p">(</span><span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the method ``f`` to ``self``, modifying ``self``.</span>
<span class="sd">        This is used to transform the commands from returning an object</span>
<span class="sd">        to modifying ``self``.</span>
<span class="sd">        The function has to return a new copy of the object (not a reference).</span>

<span class="sd">        :param f: Function to apply to ``self``.</span>
<span class="sd">        :type f:  callable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">grid_data_dict</span>
        <span class="c1"># We need to invalidate the _component_mapping (it may have changed)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_component_mapping</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_apply_binary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a binary function to the data of ``self`` and ``other``.</span>

<span class="sd">        :param function: Function to apply to all the data in the various</span>
<span class="sd">        refinement levels.</span>
<span class="sd">        :type function: callable</span>

<span class="sd">        :return: New :py:class:`~.HierarchicalGridData` with function applied to</span>
<span class="sd">        ``self.data`` and ``other.data``.</span>
<span class="sd">        :rtype: :py:class:`~.HierarchicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We only know what how to combine HierarchicalGridData</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Grid structure incompatible&quot;</span><span class="p">)</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">function</span><span class="p">(</span><span class="n">data_self</span><span class="p">,</span> <span class="n">data_other</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">data_self</span><span class="p">,</span> <span class="n">data_other</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">all_components</span>
                <span class="p">)</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">function</span><span class="p">(</span><span class="n">data_self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">data_self</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_data</span><span class="p">)</span>

        <span class="c1"># If we are here, it is because we cannot add the two objects</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;I don&#39;t know how to combine these objects&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduction</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a reduction to the data.</span>

<span class="sd">        :param function: Reduction to apply to all the data in the various</span>
<span class="sd">        refinement levels</span>
<span class="sd">        :type function: callable</span>

<span class="sd">        :return: Output of the reduction on the data.</span>
<span class="sd">        :rtype: return type of ``reduction``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assume reduction is np.min, we want the real minimum, so we have to</span>
        <span class="c1"># take the reduction of the reduction</span>
        <span class="k">return</span> <span class="n">reduction</span><span class="p">(</span>
            <span class="c1"># Here we are accessing _apply_reduction, which is a protected</span>
            <span class="c1"># member, so we ignore potential complaints.</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="c1"># skipcq: PYL-W0212</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">_apply_reduction</span><span class="p">(</span><span class="n">reduction</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span>
                <span class="p">]</span>
            <span class="p">),</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a unary function to the data.</span>

<span class="sd">        :param function: Function to apply to all the data in the various</span>
<span class="sd">        refinement levels</span>
<span class="sd">        :type function: callable</span>

<span class="sd">        :return: New :py:class:`~.HierarchicalGridData` with function applied to</span>
<span class="sd">        the data.</span>
<span class="sd">        :rtype: :py:class:`~.HierarchicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Here we are accessing _apply_unary, which is a protected member, so</span>
        <span class="c1"># we ignore potential complaints.</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="p">[</span>
            <span class="c1"># skipcq: PYL-W0212</span>
            <span class="n">data</span><span class="o">.</span><span class="n">_apply_unary</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_component_method</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">method_returns_list</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call a method on each component and return the result as a</span>
<span class="sd">        :py:class:`~.HierarchicalGridData`.</span>

<span class="sd">        :param method_name: a string that identifies one of the methods in</span>
<span class="sd">        :py:class:`~.UniformGridData`.</span>
<span class="sd">        :type method_name: str</span>

<span class="sd">        :param method_returns_list: If True, the method is expected to return a</span>
<span class="sd">                                    list, one :py:class:`~.UniformGridData` per</span>
<span class="sd">                                    dimension (e.g,</span>
<span class="sd">                                    :py:meth:`HierarchicalGridData.gradient`,</span>
<span class="sd">                                    :py:meth:`HierarchicalGridData.coordinates`).</span>
<span class="sd">        :type method_returns_list: bool</span>

<span class="sd">        :return: New :py:class:`~.HierarchicalGridData` with function applied to the data</span>
<span class="sd">        :rtype: :py:class:`~.HierarchicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;method_name has to be a string (but it is </span><span class="si">{</span><span class="n">method_name</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a_component</span><span class="p">,</span> <span class="n">method_name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;UniformGridData does not have a method with name </span><span class="si">{</span><span class="n">method_name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Here we get the method as a function with getattr(data, method_name),</span>
        <span class="c1"># then we apply this function with arguments *args and **kwargs</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span>
        <span class="p">]</span>
        <span class="c1"># There are two possibilities: new data is a list of UniformGridData</span>
        <span class="c1"># (when method_returns_list is False), alternatively it is a list of</span>
        <span class="c1"># lists of UniformGridData</span>

        <span class="c1"># First, the case in which the method returns a UniformGridData (and not</span>
        <span class="c1"># a list of UniformGridData)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">method_returns_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_data</span><span class="p">)</span>

        <span class="c1"># Second, we have a list of UniformGridData</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)([</span><span class="n">data</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">new_data</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
        <span class="p">]</span>

<div class="viewcode-block" id="HierarchicalGridData.partial_differentiated"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.partial_differentiated">[docs]</a>    <span class="k">def</span> <span class="nf">partial_differentiated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :py:class:`~.HierarchicalGridData` that is the numerical</span>
<span class="sd">        order-differentiation of the present grid_data along a given direction.</span>
<span class="sd">        (order = number of derivatives, ie ``order=2`` is second derivative)</span>

<span class="sd">        The derivative is calulated as centered differencing in the interior</span>
<span class="sd">        and one-sided derivatives at the boundaries. Higher orders are computed</span>
<span class="sd">        applying the same rule recursively.</span>

<span class="sd">        The output has the same shape of ``self``.</span>

<span class="sd">        :param order: Order of derivative (e.g. 2 = second derivative).</span>
<span class="sd">        :type order: int</span>
<span class="sd">        :param direction: Direction of the partial derivative.</span>
<span class="sd">        :type direction: int</span>

<span class="sd">        :returns:  New :py:class:`~.HierarchicalGridData` with derivative.</span>
<span class="sd">        :rtype:    :py:class:`~.HierarchicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_component_method</span><span class="p">(</span>
            <span class="s2">&quot;partial_differentiated&quot;</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.gradient"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.gradient">[docs]</a>    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list :py:class:`~.HierarchicalGridData` that are the numerical</span>
<span class="sd">        order-differentiation of the present grid_data along all the directions.</span>
<span class="sd">        (order = number of derivatives, ie ``order=2`` is second derivative)</span>

<span class="sd">        The derivative is calulated as centered differencing in the interior</span>
<span class="sd">        and one-sided derivatives at the boundaries. Higher orders are computed</span>
<span class="sd">        applying the same rule recursively.</span>

<span class="sd">        The output has the same shape of self.</span>

<span class="sd">        :param order: Order of derivative (e.g. 2 = second derivative).</span>
<span class="sd">        :type order: int</span>
<span class="sd">        :returns: list of :py:class:`~.HierarchicalGridData` with partial</span>
<span class="sd">                  derivative along all the directions.</span>
<span class="sd">        :rtype:  list of :py:class:`~.HierarchicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_component_method</span><span class="p">(</span>
            <span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="n">method_returns_list</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.partial_differentiate"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.partial_differentiate">[docs]</a>    <span class="k">def</span> <span class="nf">partial_differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a numerical differentiatin along the specified direction.</span>

<span class="sd">        The derivative is calulated as centered differencing in the interior</span>
<span class="sd">        and one-sided derivatives at the boundaries. Higher orders are computed</span>
<span class="sd">        applying the same rule recursively.</span>

<span class="sd">        The output has the same shape of ``self``.</span>

<span class="sd">        :param order: Order of derivative (e.g. 2 = second derivative).</span>
<span class="sd">        :type order: int</span>
<span class="sd">        :param direction: Direction of the partial derivative.</span>
<span class="sd">        :type direction: int</span>

<span class="sd">        :returns: Derivative along the specified direction.</span>
<span class="sd">        :rtype: list of :py:class:`~.HierarchicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partial_differentiated</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.ghost_zones_removed"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.ghost_zones_removed">[docs]</a>    <span class="k">def</span> <span class="nf">ghost_zones_removed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.HierarchicalGridData` with all the ghost zones removed.</span>

<span class="sd">        :returns: New :py:class:`~.HierarchicalGridData` without ghostzones.</span>
<span class="sd">        :rtype: :py:class:`HierarchicalGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_component_method</span><span class="p">(</span><span class="s2">&quot;ghost_zones_removed&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.ghost_zones_remove"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.ghost_zones_remove">[docs]</a>    <span class="k">def</span> <span class="nf">ghost_zones_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all the ghost zones.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ghost_zones_removed</span><span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.sliced"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.sliced">[docs]</a>    <span class="k">def</span> <span class="nf">sliced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.HierarchicalGridData` obtained slicing the current one.</span>

<span class="sd">        ``cut`` specifies how to slice the data. It has to be an array with the</span>
<span class="sd">        same number of dimensions of the data. In the entries where ``cut`` is</span>
<span class="sd">        None, that dimension is kept, where it is a number, the data is cut</span>
<span class="sd">        fixing that coordinate. For example, for a 2D array, if ``cut`` is</span>
<span class="sd">        ``[None, 2]``, the cut will be with ``y = 2``.</span>

<span class="sd">        If ``resample`` is True, you can cut at any point and we will compute</span>
<span class="sd">        the values with multilinear interpolation. If ``resample`` is False, we</span>
<span class="sd">        will use the data already available.</span>

<span class="sd">        In doing this, dimensions that are only one grid point are lost.</span>

<span class="sd">        :param cut: How to slice the array. None entries mean &quot;keep that dimension&quot;.</span>
<span class="sd">        :type cut:  array or list with dimension</span>
<span class="sd">        :param resample: Whether to use multilinear interpolation to compute the</span>
<span class="sd">                         data or simply use the value of the closest point.</span>
<span class="sd">        :type resample: bool</span>

<span class="sd">        :returns: A sliced :py:class:`~.HierachicalGridData`.</span>
<span class="sd">        :rtype: :py:class:`~.HierachicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We can use _call_component_method here because we have to handle the</span>
        <span class="c1"># errors</span>

        <span class="c1"># A HierarchicalGridData can be formed by multiple components (e.g., one</span>
        <span class="c1"># for each MPI rank). When we slice it, some components do not</span>
        <span class="c1"># contribute at all to the result. For example, if we ask for the xy</span>
        <span class="c1"># plane and a component has zmin = 3, the component should be excluded.</span>
        <span class="c1"># The slice method raises an error when the cut is outside the grid, here</span>
        <span class="c1"># we capture those errors and ignore the components that raised them.</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">sliced</span><span class="p">(</span><span class="n">cut</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;Cut point is outside the grid&quot;</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="c1"># Otherwise, do nothing</span>
                <span class="k">pass</span>  <span class="c1"># Ignore the component</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cut point is outside the grid&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.slice"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.slice">[docs]</a>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice the data along given direction.</span>

<span class="sd">        ``cut`` specifies how to slice the data. It has to be an array with the</span>
<span class="sd">        same number of dimensions of the data. In the entries where ``cut`` is</span>
<span class="sd">        None, that dimension is kept, where it is a number, the data is cut</span>
<span class="sd">        fixing that coordinate. For example, for a 2D array, if ``cut`` is</span>
<span class="sd">        ``[None, 2]``, the cut will be with ``y = 2``.</span>

<span class="sd">        If ``resample`` is True, you can cut at any point and we will compute</span>
<span class="sd">        the values with multilinear interpolation. If ``resample`` is False, we</span>
<span class="sd">        will use the data already available.</span>

<span class="sd">        In doing this, dimensions that are only one grid point are lost.</span>

<span class="sd">        :param cut: How to slice the array. None entries mean &quot;keep that dimension&quot;.</span>
<span class="sd">        :type cut:  array or list with dimension</span>
<span class="sd">        :param resample: Whether to use multilinear interpolation to compute the</span>
<span class="sd">                         data or simply use the value of the closest point.</span>
<span class="sd">        :type resample: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sliced</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="n">cut</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.coordinates"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return coordinates as a list of :py:class:`~.HierarchicalGridData`.</span>

<span class="sd">        Useful for computations involving coordinates.</span>

<span class="sd">        :returns: Coordinates.</span>
<span class="sd">        :rtype: list of :py:class:`~.HierarchicalGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_component_method</span><span class="p">(</span>
            <span class="s2">&quot;coordinates&quot;</span><span class="p">,</span> <span class="n">method_returns_list</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.coordinates_at_maximum"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.coordinates_at_maximum">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates_at_maximum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the point with maximum value.</span>

<span class="sd">        :returns:  Coordinate at where the value is maximum. If ``absolute``</span>
<span class="sd">                   is True, then the absolute value is first taken.</span>
<span class="sd">        :rtype:    1D NumPy array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">comps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span>

        <span class="c1"># We extract the maximum on each component, and find the maximum of the</span>
        <span class="c1"># maxima</span>
        <span class="n">maxima</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">if</span> <span class="n">absolute</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">comps</span>
        <span class="p">]</span>

        <span class="n">comp_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">maxima</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">comps</span><span class="p">[</span><span class="n">comp_max</span><span class="p">]</span><span class="o">.</span><span class="n">coordinates_at_maximum</span><span class="p">(</span><span class="n">absolute</span><span class="o">=</span><span class="n">absolute</span><span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.coordinates_at_minimum"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.coordinates_at_minimum">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates_at_minimum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the point with minimum value.</span>

<span class="sd">        :returns:  Coordinate at where the value is minimum. If ``absolute``</span>
<span class="sd">                   is True, then the absolute value is first taken.</span>
<span class="sd">        :rtype:    1D NumPy array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">comps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span>

        <span class="c1"># We extract the minimum on each component, and find the minimum of the</span>
        <span class="c1"># minima</span>
        <span class="n">minima</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">if</span> <span class="n">absolute</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">comps</span>
        <span class="p">]</span>

        <span class="n">comp_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">minima</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">comps</span><span class="p">[</span><span class="n">comp_min</span><span class="p">]</span><span class="o">.</span><span class="n">coordinates_at_minimum</span><span class="p">(</span><span class="n">absolute</span><span class="o">=</span><span class="n">absolute</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="s2">&quot;Available refinement levels (components):</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">ref_level</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ref_level</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ref_level</span><span class="p">])</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Spacing at coarsest level (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_coarsest_level</span><span class="si">}</span><span class="s2">): &quot;</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">coarsest_dx</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Spacing at finest level (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_finest_level</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">finest_dx</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">ret</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">kuibit 1.3.3 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">kuibit.grid_data</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020-2021, Gabriele Bozzola.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>