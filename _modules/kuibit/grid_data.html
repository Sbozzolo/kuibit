

<!doctype html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>kuibit.grid_data &#8212; kuibit 1.0.0b0 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bizstyle.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">kuibit 1.0.0b0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">kuibit.grid_data</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for kuibit.grid_data</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="c1"># Copyright (C) 2020-2021 Gabriele Bozzola</span>
<span class="c1">#</span>
<span class="c1"># This program is free software; you can redistribute it and/or modify it under</span>
<span class="c1"># the terms of the GNU General Public License as published by the Free Software</span>
<span class="c1"># Foundation; either version 3 of the License, or (at your option) any later</span>
<span class="c1"># version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1"># ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
<span class="c1"># FOR A PARTICULAR PURPOSE. See the GNU General Public License for more</span>
<span class="c1"># details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License along with</span>
<span class="c1"># this program; if not, see &lt;https://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;The :py:mod:`~.grid_data` module provides representations of data on</span>
<span class="sd">uniform grids as well as for data on refined grid hierarchies. Standard</span>
<span class="sd">arithmetic operations are supported for those data grids, further methods</span>
<span class="sd">to interpolate and resample. The number of dimensions is arbitrary.</span>

<span class="sd">The important classes defined here are</span>
<span class="sd">- :py:class:`~.UniformGrid` represents the geometry of a uniform Cartesian</span>
<span class="sd">cell-centered grid.</span>
<span class="sd">- :py:class:`~.UniformGridData` represents data on a uniform grid.</span>
<span class="sd">- :py:class:`~.HierarchicalGridData` represents data on a refined grid</span>
<span class="sd">hierarchy (AMR).</span>

<span class="sd">A :py:class:`~.UniformGridData` object contains a :py:class:`~.UniformGrid` one.</span>
<span class="sd">Similarly, a :py:class:`~.HierarchicalGridData` contains multiple</span>
<span class="sd">:py:class:`~.UniformGridData`.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">linalg</span>

<span class="kn">from</span> <span class="nn">kuibit</span> <span class="kn">import</span> <span class="n">grid_data_utils</span> <span class="k">as</span> <span class="n">gdu</span>
<span class="kn">from</span> <span class="nn">kuibit.numerical</span> <span class="kn">import</span> <span class="n">BaseNumerical</span>


<div class="viewcode-block" id="UniformGrid"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGrid">[docs]</a><span class="k">class</span> <span class="nc">UniformGrid</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Describes the geometry of a regular rectangular dataset, as well as</span>
<span class="sd">    information needed to identify the grid if part of refined grid hierarchy</span>
<span class="sd">    (namely component number and refinement level). In practice, this a fixed</span>
<span class="sd">    refinement level, or part of it (as output by an MPI process).</span>

<span class="sd">    This is a standard Cartesian grid that we will describe with the language</span>
<span class="sd">    of computer graphics. To make things clear, let&#39;s consider a 2D grid (see</span>
<span class="sd">    schematics below). We call the lower left corner &quot;origin&quot; or &quot;x0&quot;. We call</span>
<span class="sd">    the top right corner &quot;x1&quot;. The grid is cell-centered (see Fig 2).</span>

<span class="sd">    ..code-block::</span>

<span class="sd">        Fig 1</span>

<span class="sd">         o---------x1</span>
<span class="sd">         |          |</span>
<span class="sd">         |          |</span>
<span class="sd">         |          |</span>
<span class="sd">         |          |</span>
<span class="sd">        x0----------o</span>

<span class="sd">    ..code-block::</span>

<span class="sd">         Fig 2, the point sits in the center of a cell.</span>

<span class="sd">          --------</span>
<span class="sd">          |      |</span>
<span class="sd">          |  x0  |</span>
<span class="sd">          |      |</span>
<span class="sd">          --------</span>

<span class="sd">    The concept of ``shape`` is the same as NumPy shape: it&#39;s the number of points</span>
<span class="sd">    in each dimension. ``dx`` is the spacing (dx, dy, dz, ...). To fully</span>
<span class="sd">    describe a grid, one needs the ``origin``, the ``shape``, and ``x1`` or ``dx``.</span>

<span class="sd">    (This is the same convention that Carpet has.)</span>

<span class="sd">    This class is supposed to be immutable.</span>

<span class="sd">    :ivar ~.shape:     Number of points in each dimension.</span>
<span class="sd">    :type ~.shape:      1d NumPy arrary or list of int.</span>
<span class="sd">    :ivar ~.x0:    Position of cell center with lowest coordinate.</span>
<span class="sd">    :type ~.x0:     1d NumPy array or list of float.</span>
<span class="sd">    :ivar ~.dx:     If not None, specifies grid spacing, else grid</span>
<span class="sd">                      spacing is computed from x0, x1, and shape.</span>
<span class="sd">    :type ~.dx:      1d NumPy array or list of float.</span>
<span class="sd">    :ivar ~.x1:        If grid spacing is None, this specifies the</span>
<span class="sd">                      position of the cell center with largest</span>
<span class="sd">                      coordinates.</span>
<span class="sd">    :type ~.x1:         1d NumPy array or list of float.</span>
<span class="sd">    :ivar ~.ref_level:  Refinement level if this belongs to a hierarchy,</span>
<span class="sd">                      else -1.</span>
<span class="sd">    :type ~.ref_level:   int</span>
<span class="sd">    :ivar ~.component: Component number if this belongs to a hierarchy,</span>
<span class="sd">                      else -1.</span>
<span class="sd">    :type ~.component:  int</span>
<span class="sd">    :ivar ~.num_ghost:    Number of ghost zones (default=0)</span>
<span class="sd">    :type ~.num_ghost:     1d NumPy arrary or list of int.</span>
<span class="sd">    :ivar ~.time:      Time if that makes sense, else None.</span>
<span class="sd">    :type ~.time:       float or None</span>
<span class="sd">    :ivar ~.iteration: Iteration if that makes sense, else None.</span>
<span class="sd">    :type ~.iteration:  float or None</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_check_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check that the dimensions are consistent with the shape of the object.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> must not be multi-dimensional </span><span class="si">{</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The dimensions of this object are </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;not </span><span class="si">{</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">,</span>
        <span class="n">x0</span><span class="p">,</span>
        <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ref_level</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">component</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">num_ghost</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">iteration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param shape:     Number of points in each dimension.</span>
<span class="sd">        :type shape:      1d NumPy arrary or list of int.</span>
<span class="sd">        :param x0:    Position of cell center with lowest coordinate.</span>
<span class="sd">        :type x0:     1d NumPy array or list of float.</span>
<span class="sd">        :param dx:     If not None, specifies grid spacing, else grid</span>
<span class="sd">                          spacing is computed from x0, x1, and shape.</span>
<span class="sd">        :type dx:      1d NumPy array or list of float.</span>
<span class="sd">        :param x1:        If grid spacing is None, this specifies the</span>
<span class="sd">                          position of the cell center with largest</span>
<span class="sd">                          coordinates.</span>
<span class="sd">        :type x1:         1d NumPy array or list of float.</span>
<span class="sd">        :param ref_level:  Refinement level if this belongs to a hierarchy,</span>
<span class="sd">                          else -1.</span>
<span class="sd">        :type ref_level:   int</span>
<span class="sd">        :param component: Component number if this belongs to a hierarchy,</span>
<span class="sd">                          else -1.</span>
<span class="sd">        :type component:  int</span>
<span class="sd">        :param num_ghost:    Number of ghost zones (default=0)</span>
<span class="sd">        :type num_ghost:     1d NumPy arrary or list of int.</span>
<span class="sd">        :param time:      Time if that makes sense, else None.</span>
<span class="sd">        :type time:       float or None</span>
<span class="sd">        :param iteration: Iteration if that makes sense, else None.</span>
<span class="sd">        :type iteration:  float or None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;shape&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="s2">&quot;x0&quot;</span><span class="p">)</span>

        <span class="c1"># Internally, what is important is shape, x0 and dx</span>

        <span class="k">if</span> <span class="n">dx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide one between x1 and dx&quot;</span><span class="p">)</span>

            <span class="c1"># Here x1 is given, we compute dx. Consider the case</span>
            <span class="c1"># with three cells, x0 = (0,0) and x1 = (4,4).</span>
            <span class="c1"># Since we work with cell-centered, the x=0 line would</span>
            <span class="c1"># look like:</span>
            <span class="c1">#</span>
            <span class="c1"># --|------|------|------|------|--</span>
            <span class="c1"># (0,0)  (1,0)  (2,0)  (3,0)  (4,0)</span>
            <span class="c1">#</span>
            <span class="c1"># If we want a dx of 1, we have need 5 points. Vice versa,</span>
            <span class="c1"># if we have n points, dx is (x1 - x0)/(n - 1).</span>
            <span class="n">x1_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_dims</span><span class="p">(</span><span class="n">x1_arr</span><span class="p">,</span> <span class="s2">&quot;x1&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">&lt;=</span> <span class="n">x1_arr</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;x1 </span><span class="si">{</span><span class="n">x1_arr</span><span class="si">}</span><span class="s2"> should be the upper corner (x0 = </span><span class="si">{</span><span class="n">x0</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
            <span class="c1"># We have to deal with grid with only one point along one direction.</span>
            <span class="c1"># When that happens, the only way to produce a grid that makes sense</span>
            <span class="c1"># is to have x0 and dx, because for those grids x0 = x1 along the</span>
            <span class="c1"># direction that has one single point.</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot initialize a grid with a dimension&quot;</span>
                    <span class="s2">&quot; that has only one grid point by providing&quot;</span>
                    <span class="s2">&quot; x0 and x1. You must provide dx&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1_arr</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Here we assume dx is given, but if also x1 is given, that</span>
            <span class="c1"># would may lead to problems if the paramters do not agree. So, we</span>
            <span class="c1"># first compute what x1 would be given x0 and dx, then if x1</span>
            <span class="c1"># is provided, we compare the result with the given x1. We raise an</span>
            <span class="c1"># error if they disagree.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="s2">&quot;dx&quot;</span><span class="p">)</span>
            <span class="n">expected_x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">expected_x1</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible x1 and dx&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_ghost</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__num_ghost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__num_ghost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">num_ghost</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">,</span> <span class="s2">&quot;num_ghost&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__ref_level</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ref_level</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__component</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__time</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__iteration</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">iteration</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

        <span class="c1"># The coordinates are a widely requested property, so the first time the</span>
        <span class="c1"># coordinates 1d are computed, we save them here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__coordinates_1d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Same with x1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__x1</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># The method __contains__ is called extremely often when dealing with</span>
        <span class="c1"># HierachicalGridData (because it is used to find which subgrid</span>
        <span class="c1"># contains a point). So, to make it faster, we save the values of the</span>
        <span class="c1"># bottom and upper cell faces (we account for the fact that the grid</span>
        <span class="c1"># is cell centered)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lowest_vertex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__highest_vertex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Same considerations for num_dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__num_dimensions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;UniformGrid is immutable, we can define an hash as the composition of</span>
<span class="sd">        the hashes of the members. This hash is quite slow to compute, so it</span>
<span class="sd">        is not useful for caching small computations. Having an hash function</span>
<span class="sd">        solidifies the idea that this class is immutable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We convert all the arrays in tuples (because they are hashable)</span>
        <span class="n">hash_shape</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">hash_x0</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">))</span>
        <span class="n">hash_dx</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">))</span>
        <span class="n">hash_num_ghost</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">))</span>
        <span class="n">hash_ref_level</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="p">)</span>
        <span class="n">hash_component</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">)</span>
        <span class="n">hash_time</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="n">hash_iteration</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">)</span>

        <span class="c1"># ^ = bitwise xor</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">hash_shape</span>
            <span class="o">^</span> <span class="n">hash_x0</span>
            <span class="o">^</span> <span class="n">hash_dx</span>
            <span class="o">^</span> <span class="n">hash_num_ghost</span>
            <span class="o">^</span> <span class="n">hash_ref_level</span>
            <span class="o">^</span> <span class="n">hash_component</span>
            <span class="o">^</span> <span class="n">hash_time</span>
            <span class="o">^</span> <span class="n">hash_iteration</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lower corner.</span>

<span class="sd">        :returns: Center of lowest corner grid point.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__x0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of cells across each dimension.</span>

<span class="sd">        :returns: Number of cells across each dimension.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Upper corner.</span>

<span class="sd">        :returns: Center of top corner grid point.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We save x1 because it is computed a lot of times</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__x1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__x1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lower corner.</span>

<span class="sd">        Alias for :py:meth:`~.x0`.</span>

<span class="sd">        :returns: Center of lowest corner grid point.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__x0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Grid spacing.</span>

<span class="sd">        :returns: Cell size across each dimension.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dx</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Grid spacing.</span>

<span class="sd">        Alias for :py:meth:`~.dx`.</span>

<span class="sd">        :returns: Cell size across each dimension.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dx</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_ghost</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of ghost zones.</span>

<span class="sd">        :returns: Number of ghost zones across each dimension.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__num_ghost</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ref_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Refinement level number.</span>

<span class="sd">        :returns: Refinement level number.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ref_level</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Component number.</span>

<span class="sd">        :returns: Component number.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__component</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Time.</span>

<span class="sd">        :returns: Time.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__time</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iteration number</span>

<span class="sd">        :returns: Iteration number.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__iteration</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Volume of a grid cell.</span>

<span class="sd">        :returns: Volume of a grid cell.</span>
<span class="sd">        :rtype:   float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Volume of the whole grid.</span>

<span class="sd">        :returns: Volume of the whole grid.</span>
<span class="sd">        :rtype:   float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dv</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of dimensions of the grid.</span>

<span class="sd">        :returns: Number of dimensions of the grid.</span>
<span class="sd">        :rtype:   float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__num_dimensions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">extended_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an array of bools with whether a dimension has more than one</span>
<span class="sd">        point or not.</span>

<span class="sd">        :returns: Dimensions with more than one point.</span>
<span class="sd">        :rtype:   1d NumPy of bools</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">&gt;</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_extended_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of dimensions with size larger than one gridpoint.</span>

<span class="sd">        :returns: The number of extended dimensions (the ones with more than one cell).</span>
<span class="sd">        :rtype:   int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extended_dimensions</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lowest_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the location of the lowest cell vertex (considering that</span>
<span class="sd">        the grid is cell centered).</span>

<span class="sd">        :returns: Lowest vertex of the lowest cell.</span>
<span class="sd">        :rtype:   1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lowest_vertex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__lowest_vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lowest_vertex</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">highest_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the location of the highest cell vertex (considering that</span>
<span class="sd">        the grid is cell centered).</span>

<span class="sd">        :returns: Highest vertex of the highest cell.</span>
<span class="sd">        :rtype:   1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__highest_vertex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__highest_vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x1</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__highest_vertex</span>

<div class="viewcode-block" id="UniformGrid.indices_to_coordinates"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGrid.indices_to_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">indices_to_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute coordinate corresponding to one or more grid points.</span>

<span class="sd">        :param indices: Grid indices.</span>
<span class="sd">        :type indices:  1d array or list of int</span>
<span class="sd">        :returns: Corresponding coordinates of the grid points.</span>
<span class="sd">        :rtype:   1d NumPy array of float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO (FEATURE): Add dimensionality checks</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span></div>

<div class="viewcode-block" id="UniformGrid.coordinates_to_indices"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGrid.coordinates_to_indices">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates_to_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the indices corresponding to the point nearest to the given coordinates.</span>

<span class="sd">        :param coordinates: Coordinates.</span>
<span class="sd">        :type coordinates:  1d NumPy array or list of float</span>
<span class="sd">        :returns: Grid indices of nearest points.</span>
<span class="sd">        :rtype:   NumPy array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO (FEATURE): Add dimensionality checks</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">indices</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the coordinates corresponding to a given (multi-dimensional)</span>
<span class="sd">        index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dims</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">)</span>
        <span class="n">coordinate</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="k">if</span> <span class="n">coordinate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2"> is not in on the grid&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coordinate</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if a coordinate is contained in the grid. The size of the</span>
<span class="sd">        grid cells is taken into account, resulting in a cube larger by</span>
<span class="sd">        dx/2 on each side compared to the one given by x0, x1.</span>

<span class="sd">        :param point: Coordinate to test.</span>
<span class="sd">        :type point:  1d NumPy array or list of float.</span>
<span class="sd">        :returns:   If point is contained.</span>
<span class="sd">        :rtype:     bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># A pythonic way to write this function is:</span>
        <span class="c1"># if np.any(point &lt; (self.lowest_vertex)) or np.any(</span>
        <span class="c1">#     point &gt;= (self.highest_vertex)</span>
        <span class="c1"># ):</span>
        <span class="c1">#     return False</span>
        <span class="c1"># return True</span>

        <span class="c1"># However, this happens to be not the fastest. This method is called a</span>
        <span class="c1"># huge number of times when in HierarchicalGridData methods, because it</span>
        <span class="c1"># is the main method to find which grid contains a given point.</span>
        <span class="c1"># (method finest_level_component_at_point). So, it is better to have</span>
        <span class="c1"># a less pythonic method that fails as soon as possible.</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lowest_vertex</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                <span class="o">&lt;=</span> <span class="n">point</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">highest_vertex</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="UniformGrid.contains"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGrid.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if a coordinate is contained in the grid. The size of the</span>
<span class="sd">        grid cells is taken into account, resulting in a cube larger by</span>
<span class="sd">        dx/2 on each side compared to the one given by x0, x1.</span>

<span class="sd">        :param point: Coordinate to test.</span>
<span class="sd">        :type point:  1d NumPy array or list of float.</span>
<span class="sd">        :returns:   If point is contained.</span>
<span class="sd">        :rtype:     bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coordinates_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return coordinates of the grid points.</span>

<span class="sd">        The return value is a list with the coordinates along each direction.</span>

<span class="sd">        :returns: Coordinates of the grid points on each direction.</span>
<span class="sd">        :rtype: list of 1d NumPy array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__coordinates_1d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__coordinates_1d</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x1</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__coordinates_1d</span>

<div class="viewcode-block" id="UniformGrid.coordinates"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGrid.coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_meshgrid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">as_same_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return coordinates of the grid points.</span>

<span class="sd">        If ``as_meshgrid`` is True, the coordinates are returned as NumPy</span>
<span class="sd">        meshgrid. Otherwise, return the coordinates of the grid points as 1D</span>
<span class="sd">        arrays (schematically, [array for x coordinates, array for y</span>
<span class="sd">        coordinates, ...]).</span>

<span class="sd">        If ``as_same_shape`` is True return the coordinates as an array with the</span>
<span class="sd">        same shape of self and with values the coordinates. This is useful for</span>
<span class="sd">        computations involving the coordinates. The output of ``as_same_shape``</span>
<span class="sd">        is the same as using ``np.mgrid``.</span>

<span class="sd">        :param as_meshgrid: If True, return the coordinates as meshgrid.</span>
<span class="sd">        :type as_meshgrid: bool</span>
<span class="sd">        :param as_same_shape: If True, return the coordinates as a list</span>
<span class="sd">                              or coordinates with the same shape of self</span>
<span class="sd">                              and with values of a given coordinate.</span>
<span class="sd">                              For instance, if ``self.num_dimension = 3`` there</span>
<span class="sd">                              will be three lists with ``shape = self.shape``.</span>
<span class="sd">                              This is equivalent to ``np.mgrid``.</span>
<span class="sd">        :type as_same_shape: bool</span>
<span class="sd">        :returns:  Grid coordinates.</span>
<span class="sd">        :rtype:   list of NumPy arrays with the same shape as grid</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">as_meshgrid</span> <span class="ow">and</span> <span class="n">as_same_shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot ask for both meshgrid and shaped array.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">as_meshgrid</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates_1d</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">as_same_shape</span><span class="p">:</span>
            <span class="c1"># np.indeces prepares an array in which each element has the value</span>
            <span class="c1"># of its index</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1"># Here we transform the index into coordinate, along each dimension</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates_1d</span></div>

<div class="viewcode-block" id="UniformGrid.flat_dimensions_removed"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGrid.flat_dimensions_removed">[docs]</a>    <span class="k">def</span> <span class="nf">flat_dimensions_removed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.UniformGrid` with dimensions that have no</span>
<span class="sd">        flat dimensions (dimensions with only one grid point).</span>

<span class="sd">        :returns: Return a new grid without flat dimensions.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGrid`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We need this infrastructure to slice UniformGridData</span>

        <span class="n">copied</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># We have to save this, otherwise it would be recomputed at every line,</span>
        <span class="c1"># affecting the result.</span>
        <span class="n">extended_dims</span> <span class="o">=</span> <span class="n">copied</span><span class="o">.</span><span class="n">extended_dimensions</span>

        <span class="n">copied</span><span class="o">.</span><span class="n">__shape</span> <span class="o">=</span> <span class="n">copied</span><span class="o">.</span><span class="n">__shape</span><span class="p">[</span><span class="n">extended_dims</span><span class="p">]</span>
        <span class="n">copied</span><span class="o">.</span><span class="n">__x0</span> <span class="o">=</span> <span class="n">copied</span><span class="o">.</span><span class="n">__x0</span><span class="p">[</span><span class="n">extended_dims</span><span class="p">]</span>
        <span class="n">copied</span><span class="o">.</span><span class="n">__dx</span> <span class="o">=</span> <span class="n">copied</span><span class="o">.</span><span class="n">__dx</span><span class="p">[</span><span class="n">extended_dims</span><span class="p">]</span>
        <span class="n">copied</span><span class="o">.</span><span class="n">__num_ghost</span> <span class="o">=</span> <span class="n">copied</span><span class="o">.</span><span class="n">__num_ghost</span><span class="p">[</span><span class="n">extended_dims</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">copied</span></div>

<div class="viewcode-block" id="UniformGrid.ghost_zones_removed"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGrid.ghost_zones_removed">[docs]</a>    <span class="k">def</span> <span class="nf">ghost_zones_removed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.UniformGrid` with ghostzones removed.</span>

<span class="sd">        :returns: Return a new grid without ghost zones.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGrid`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">copied</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># We remove twice the number of ghost zones because there are</span>
        <span class="c1"># lower and upper ghostzones</span>
        <span class="n">copied</span><span class="o">.</span><span class="n">__shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span>
        <span class="c1"># We &quot;push x0 inside the grid&quot;</span>
        <span class="n">copied</span><span class="o">.</span><span class="n">__x0</span> <span class="o">=</span> <span class="n">copied</span><span class="o">.</span><span class="n">__x0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
        <span class="n">copied</span><span class="o">.</span><span class="n">__num_ghost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">copied</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">copied</span></div>

<div class="viewcode-block" id="UniformGrid.shifted"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGrid.shifted">[docs]</a>    <span class="k">def</span> <span class="nf">shifted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new UniformGrid with coordinates shifted by the given amount.</span>

<span class="sd">        ``x -&gt; x + shift``.</span>

<span class="sd">        :param shift: Amount to shift coordinates.</span>
<span class="sd">        :type shift: 1d NumPy array</span>
<span class="sd">        :returns: New grid with coordinates shifted.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGrid`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dims</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="s2">&quot;shift&quot;</span><span class="p">)</span>

        <span class="n">copied</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># We only need to shift x0 because x1 is computed from x0 using dx</span>
        <span class="n">copied</span><span class="o">.</span><span class="n">__x0</span> <span class="o">=</span> <span class="n">copied</span><span class="o">.</span><span class="n">__x0</span> <span class="o">+</span> <span class="n">shift</span>
        <span class="k">return</span> <span class="n">copied</span></div>

<div class="viewcode-block" id="UniformGrid.copy"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGrid.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a deep copy.</span>

<span class="sd">        :returns:  Deep copy of the UniformGrid.</span>
<span class="sd">        :rtype:    :py:class:`~.UniformGrid`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span>
            <span class="n">dx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span>
            <span class="n">x1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span>
            <span class="n">ref_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span>
            <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">,</span>
            <span class="n">num_ghost</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="n">iteration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if two :py:class:`~.UniformGrid` are the equal up to numerical</span>
<span class="sd">        precision.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Time and iterations can be None, so we check them independently</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># In this case one of the two is None (or both)</span>
            <span class="n">time_bool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">iteration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">iteration_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># In this case one of the two is None (or both)</span>
            <span class="n">iteration_bool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">iteration</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">component</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">time_bool</span>
            <span class="ow">and</span> <span class="n">iteration_bool</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:returns: a string describing the geometry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;Shape            = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"></span>
<span class="s2">Num ghost zones  = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="si">}</span><span class="s2"></span>
<span class="s2">Ref. level       = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="si">}</span><span class="s2"></span>
<span class="s2">Component        = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="si">}</span><span class="s2"></span>
<span class="s2">x0               = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="si">}</span><span class="s2"></span>
<span class="s2">x0/dx            = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="si">}</span><span class="s2"></span>
<span class="s2">x1               = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x1</span><span class="si">}</span><span class="s2"></span>
<span class="s2">x1/dx            = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="si">}</span><span class="s2"></span>
<span class="s2">Volume           = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="si">}</span><span class="s2"></span>
<span class="s2">dx               = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="si">}</span><span class="s2"></span>
<span class="s2">Time             = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="si">}</span><span class="s2"></span>
<span class="s2">Iteration        = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="si">}</span><span class="s2"></span>
<span class="s2">&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="UniformGridData"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData">[docs]</a><span class="k">class</span> <span class="nc">UniformGridData</span><span class="p">(</span><span class="n">BaseNumerical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a rectangular data grid with coordinates, supporting</span>
<span class="sd">    common arithmetic operations.</span>

<span class="sd">    :py:class:`~.UniformGridData` is a combination of a</span>
<span class="sd">    :py:class:`~.UniformGrid` (in ``grid`` attribute) and the actual data (in</span>
<span class="sd">    the ``data`` attribute). :py:class:`~.UniformGridData` makes sure that all</span>
<span class="sd">    the operations on these objects are intuitive, meaningful, and consistent.</span>

<span class="sd">    A :py:class:`~.UniformGridData` can be initialized with the default</span>
<span class="sd">    constructor (which takes grid and data), of with the alternative constructor</span>
<span class="sd">    :py:meth:`~.from_grid_structure` (which takes grid details and data).</span>

<span class="sd">    :ivar grid: Uniform grid over which the data is defined.</span>
<span class="sd">    :type grid: :py:class:`~.UniformGrid`</span>
<span class="sd">    :ivar data: The actual data.</span>
<span class="sd">    :type data: NumPy array.</span>

<span class="sd">    :ivar invalid_spline: Whether the spline stored is valid.</span>
<span class="sd">    :type invalid_spline: bool</span>

<span class="sd">    :ivar spline_real: Spline representation of the real part of the data.</span>
<span class="sd">    :type spline_real: SciPy&#39;s RegularGridInterpolator, or None</span>

<span class="sd">    :ivar spline_imag: Spline representation of the imaginary part of the data.</span>
<span class="sd">    :type spline_imag: SciPy&#39;s RegularGridInterpolator, or None</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># We are deriving this from BaseNumerical. This will give all the</span>
    <span class="c1"># mathematical operators for free, as long as we defined _apply_unary</span>
    <span class="c1"># and _apply_binary.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param grid: Uniform grid over which the data is defined.</span>
<span class="sd">        :type grid: :py:class:`~.UniformGrid`</span>
<span class="sd">        :param data: The data.</span>
<span class="sd">        :type data: A NumPy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">UniformGrid</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;grid has to be a UniformGrid&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;grid and data shapes differ </span><span class="si">{</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># We keep this flag around to know when we have to recompute the</span>
        <span class="c1"># splines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalid_spline</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># Here we also define the splines as empty objects so that we know that</span>
        <span class="c1"># they are attributes of the class and they are not uninitialized.</span>
        <span class="c1"># These attributes will store data relevant for evaluating the spline.</span>
        <span class="c1"># This will be an object of type SciPy&#39;s RegularGridInterpolator.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spline_real</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spline_imag</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># This is a class method. It doesn&#39;t depend on the specific instance, and</span>
    <span class="c1"># it is used as an alternative constructor.</span>
<div class="viewcode-block" id="UniformGridData.from_grid_structure"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.from_grid_structure">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_grid_structure</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">x0</span><span class="p">,</span>
        <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ref_level</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">component</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">num_ghost</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">iteration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param x0:    Position of cell center with lowest coordinate.</span>
<span class="sd">        :type x0:     1d NumPy array or list of float.</span>
<span class="sd">        :param dx:     If not None, specifies grid spacing, else grid</span>
<span class="sd">                          spacing is computed from x0, x1, and shape.</span>
<span class="sd">        :type dx:      1d NumPy array or list of float.</span>
<span class="sd">        :param data:      The data.</span>
<span class="sd">        :type data:       A NumPy array.</span>
<span class="sd">        :param ref_level:  Refinement level if this belongs to a hierarchy,</span>
<span class="sd">                          else -1.</span>
<span class="sd">        :type ref_level:   int</span>
<span class="sd">        :param component: Component number if this belongs to a hierarchy,</span>
<span class="sd">                          else -1.</span>
<span class="sd">        :type component:  int</span>
<span class="sd">        :param num_ghost:    Number of ghost zones (default=0)</span>
<span class="sd">        :type num_ghost:     1d NumPy arrary or list of int.</span>
<span class="sd">        :param time:      Time if that makes sense, else None.</span>
<span class="sd">        :type time:       float or None</span>
<span class="sd">        :param iteration: Iteration if that makes sense, else None.</span>
<span class="sd">        :type iteration:  float or None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">UniformGrid</span><span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">x0</span><span class="p">,</span>
            <span class="n">x1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
            <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span>
            <span class="n">ref_level</span><span class="o">=</span><span class="n">ref_level</span><span class="p">,</span>
            <span class="n">component</span><span class="o">=</span><span class="n">component</span><span class="p">,</span>
            <span class="n">num_ghost</span><span class="o">=</span><span class="n">num_ghost</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
            <span class="n">iteration</span><span class="o">=</span><span class="n">iteration</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.coordinates"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return coordinates of the grid points as list of</span>
<span class="sd">        :py:class:`~.UniformGridData`.</span>

<span class="sd">        This can be used for computations involving the coordinates.</span>

<span class="sd">        :returns: Coordinates along each direction.</span>
<span class="sd">        :rtype: list of :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">coord</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates_from_grid</span><span class="p">(</span><span class="n">as_same_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="UniformGridData.coordinates_from_grid"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.coordinates_from_grid">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates_from_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_meshgrid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">as_same_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return coordinates of the grid points.</span>

<span class="sd">        This is equivalent to ``self.grid.coordinates()``.</span>

<span class="sd">        If ``as_meshgrid`` is True, the coordinates are returned as NumPy</span>
<span class="sd">        meshgrid. Otherwise, return the coordinates of the grid points as 1D</span>
<span class="sd">        arrays (schematically, [array for x coordinates, array for y</span>
<span class="sd">        coordinates, ...]).</span>

<span class="sd">        If ``as_same_shape`` is True return the coordinates as an array with the</span>
<span class="sd">        same shape of self and with values the coordinates. This is useful for</span>
<span class="sd">        computations involving the coordinates.</span>

<span class="sd">        :param as_meshgrid: If True, return the coordinates as meshgrid.</span>
<span class="sd">        :type as_meshgrid: bool</span>
<span class="sd">        :param as_same_shape: If True, return the coordinates as a list</span>
<span class="sd">                              or coordinates with the same shape of self</span>
<span class="sd">                              and with values of a given coordinate.</span>
<span class="sd">                              For instance, if ``self.num_dimension = 3`` there</span>
<span class="sd">                              will be three lists with ``shape = self.shape``.</span>
<span class="sd">        :type as_same_shape: bool</span>
<span class="sd">        :returns:  Grid coordinates.</span>
<span class="sd">        :rtype:   list of NumPy arrays with the same shape as grid</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span>
            <span class="n">as_meshgrid</span><span class="o">=</span><span class="n">as_meshgrid</span><span class="p">,</span> <span class="n">as_same_shape</span><span class="o">=</span><span class="n">as_same_shape</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.coordinates_meshgrid"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.coordinates_meshgrid">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates_meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return coordinates of the grid points as NumPy meshgrid.</span>

<span class="sd">        This is syntactic sugar useful for plotting with matplotlib.</span>

<span class="sd">        :returns:  Grid coordinates.</span>
<span class="sd">        :rtype:   list of NumPy arrays</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates_from_grid</span><span class="p">(</span><span class="n">as_meshgrid</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the data, but transposed.</span>

<span class="sd">        This is useful when plotting, because we store data in a matrix form,</span>
<span class="sd">        which is the transposed of what we are used to thinking about coordinates</span>
<span class="sd">        (ie, the first index is not ``x``).</span>

<span class="sd">        :returns: Data in a coordinate-friendly form.</span>
<span class="sd">        :rtype: NumPy array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

<div class="viewcode-block" id="UniformGridData.save"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Saves into data and grid information in ASCII file.</span>

<span class="sd">        This method supports (and encourages) compression of the data. To enable</span>
<span class="sd">        compression, just append ``bz`` or ``gz`` to the extension.</span>

<span class="sd">        All the unknown arguments are passed to ``np.savetxt``.</span>

<span class="sd">        The backend used by the method does not support writing 3D or larger</span>
<span class="sd">        arrays to disk as ASCII, all the arrays reshaped to 1D.</span>

<span class="sd">        The file output with this method can be read with the</span>
<span class="sd">        :py:func:`~.load_UniformGridData` function.</span>

<span class="sd">        :param file_name: Path (with extension) of the output file.</span>
<span class="sd">        :type file_name: str</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># In the header we save all the metadata for the grid.</span>
        <span class="c1"># We will use colons to read the data from the comment</span>
        <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;shape: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;x0: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;dx: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;ref_level: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;component: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;num_ghost: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;time: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;iteration: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span>
            <span class="n">file_name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
            <span class="p">),</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lower corner.</span>

<span class="sd">        :returns: Center of lowest corner grid point.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">x0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of cells across each dimension.</span>

<span class="sd">        :returns: Number of cells across each dimension.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Upper corner.</span>

<span class="sd">        :returns: Center of top corner grid point.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">x1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lower corner.</span>

<span class="sd">        Alias for :py:meth:`~.x0`.</span>

<span class="sd">        :returns: Center of lowest corner grid point.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Grid spacing.</span>

<span class="sd">        :returns: Cell size across each dimension.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dx</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Grid spacing.</span>

<span class="sd">        Alias for :py:meth:`~.dx`.</span>

<span class="sd">        :returns: Cell size across each dimension.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_ghost</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of ghost zones.</span>

<span class="sd">        :returns: Number of ghost zones across each dimension.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">num_ghost</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ref_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Refinement level number.</span>

<span class="sd">        :returns: Refinement level number.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">ref_level</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Component number.</span>

<span class="sd">        :returns: Component number.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">component</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Time.</span>

<span class="sd">        :returns: Time.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">time</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iteration number</span>

<span class="sd">        :returns: Iteration number.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">iteration</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_make_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Private function to make spline representation of the data using</span>
<span class="sd">        ``scipy.interpolate.RegularGridInterpolator``.</span>

<span class="sd">        Only nearest neighbor or multilinear interpolations are available.</span>

<span class="sd">        Computing spline is memory intenstive: 150 MB/million points.</span>

<span class="sd">        This function is not meant to be called directly.</span>

<span class="sd">        :param k: Order of the interpolation (k = 0 or 1).</span>
<span class="sd">        :type k:  int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Order for splines for dimensions &gt; 2 must be 0 or 1&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Here k is 0 or 1</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span> <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;linear&quot;</span>

        <span class="c1"># Our grid is cell-centered, so it is perfecly valid to evaluate a point</span>
        <span class="c1"># that it is outside coords, as long as it is within 0.5 * dx. For</span>
        <span class="c1"># example, if the grid is linear from 0 to 10 with dx = 1, the pint</span>
        <span class="c1"># -0.25 is in the grid. To account for this in splines (to avoid that</span>
        <span class="c1"># they throw an error), we add another point at the two boundaries. This</span>
        <span class="c1"># point as the same value as the last point (which is equivalent to a</span>
        <span class="c1"># 0th order interpolation at the very last half cell).</span>

        <span class="c1"># With this, the grid has uneven spacing.</span>
        <span class="c1"># Add an element at the beginning and end</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">index</span><span class="p">]],</span>
                    <span class="n">coord</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">index</span><span class="p">]],</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Add the border</span>
        <span class="n">data_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spline_real</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">RegularGridInterpolator</span><span class="p">(</span>
            <span class="n">coords</span><span class="p">,</span>
            <span class="n">data_real</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">bounds_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
            <span class="n">data_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spline_imag</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">RegularGridInterpolator</span><span class="p">(</span>
                <span class="n">coords</span><span class="p">,</span>
                <span class="n">data_imag</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">bounds_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">invalid_spline</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_nearest_neighbor_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return data of nearest neighbors of given points x.</span>

<span class="sd">        :param x: Points where to evaluate the data.</span>
<span class="sd">        :type x: 1D NumPy array of float, or :py:class:`~.UniformGrid`</span>

<span class="sd">        :param ext: How to deal values outside the boundaries. Values outside</span>
<span class="sd">                    the interval are set to 0 if ``ext=1``,</span>
<span class="sd">                    or an error is raised if ``ext=2``.</span>
<span class="sd">        :type ext:  int</span>

<span class="sd">        :returns: Values of the data evaluated on the input ``x``.</span>
<span class="sd">        :rtype:   1D NumPy array or float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># To implement the piecewise constant spline, we just lookup the</span>
        <span class="c1"># data, so first we get the corresponding indices.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">coordinates_to_indices</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="c1"># We need the array version because we are going to modify the values</span>
        <span class="n">indices_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="c1"># Here we have to directly implement the support for ext = 1 and</span>
        <span class="c1"># ext = 2. We find all the points that are outside the</span>
        <span class="c1"># boundaries.</span>

        <span class="c1"># Here we check for every point if they have have negative index</span>
        <span class="c1"># or index larger than the shape (number of points)</span>
        <span class="n">outside_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indices_arr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indices_arr</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">outside_indices</span><span class="p">):</span>
                <span class="c1"># For ext = 2, we simply have the raise an error if we have</span>
                <span class="c1"># any outside_index</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Point outside the grid&quot;</span><span class="p">)</span>
            <span class="c1"># NumPy fancy indexing consists in a list of N tuples each</span>
            <span class="c1"># representing a coordinate, so we have to reshape the indices.</span>
            <span class="c1"># Here we use this trick:</span>
            <span class="c1"># *indices unpacks the indices so that the iterator is over each</span>
            <span class="c1"># point. Then, we zip them, which means that we take one element</span>
            <span class="c1"># at the time from each dimension. Finally, we convert this iterator</span>
            <span class="c1"># to a tuple</span>
            <span class="n">take_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">take_indices</span><span class="p">]</span>

        <span class="c1"># Here we are with ext = 1. If we were to call self.data[indices], we</span>
        <span class="c1"># would have errors because we are trying to access elements outside the</span>
        <span class="c1"># array. Therefore, we change these indices to a value. We will</span>
        <span class="c1"># overwrite that value with 0 later.</span>

        <span class="c1"># Here we substitute those elements that are outside with the point</span>
        <span class="c1"># (0, 0, 0, ...) (N zeros with 0 is num dimension)</span>
        <span class="n">indices_arr</span><span class="p">[</span><span class="n">outside_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span>
        <span class="p">)</span>

        <span class="c1"># See comment ~10 lines above for what this means</span>
        <span class="n">take_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">indices_arr</span><span class="p">))</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">take_indices</span><span class="p">]</span>

        <span class="n">ret</span><span class="p">[</span><span class="n">outside_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">ret</span>

<div class="viewcode-block" id="UniformGridData.evaluate_with_spline"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.evaluate_with_spline">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_with_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the spline on the points ``x``.</span>

<span class="sd">        Values outside the interval are set to 0 if ``ext=1``, or a</span>
<span class="sd">        ``ValueError`` is raised if ``ext=2``.</span>

<span class="sd">        This method is meant to be used only if you want to use a different ext</span>
<span class="sd">        for a specific call, otherwise, just use __call__.</span>

<span class="sd">        :param x: Points where to evaluate the data.</span>
<span class="sd">        :type x: 1D NumPy array of float, or :py:class:`~.UniformGrid`</span>

<span class="sd">        :param ext: How to deal values outside the boundaries. Values outside</span>
<span class="sd">                    the interval are set to 0 if ``ext=1``,</span>
<span class="sd">                    or an error is raised if ``ext=2``.</span>
<span class="sd">        :type ext:  int</span>

<span class="sd">        :returns: Values of the data evaluated on the input ``x``.</span>
<span class="sd">        :rtype:   1D NumPy array or float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ext = 0 is extrapolation and ext = 3 is setting the boundary</span>
        <span class="c1"># value. We cannot do this with RegularGridInterpolator</span>

        <span class="c1"># TODO (FEATURE): Implement ext = 3</span>
        <span class="c1">#</span>
        <span class="c1"># We can implement ext = 3 by clamping the indices.</span>

        <span class="k">if</span> <span class="n">ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only ext=1 or ext=2 are available&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">UniformGrid</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">num_dimensions</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Incompatible dimensions between input and self&quot;</span>
                <span class="p">)</span>
            <span class="c1"># The way we want the coordinates is like as an array with the same</span>
            <span class="c1"># shape of the grid and with values the coordinates (as arrays).</span>
            <span class="c1"># This is similar to as_same_shape, but the coordinates have to be</span>
            <span class="c1"># the value, and not the first index.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">as_same_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Now we make sure we have an array</span>
        <span class="n">x_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># We determine what is the shape of the points forgetting about</span>
        <span class="c1"># their dimensionality (which we don&#39;t need). We use this reshape</span>
        <span class="c1"># the output.</span>
        <span class="n">points_shape</span> <span class="o">=</span> <span class="n">x_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Next, we reshape up to the last axis, which means that</span>
        <span class="c1"># now we have a collection of points</span>
        <span class="n">x_arr</span> <span class="o">=</span> <span class="n">x_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">piecewise_constant</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_extended_dimensions</span>
        <span class="p">):</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nearest_neighbor_interpolation</span><span class="p">(</span><span class="n">x_arr</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We are here only with method = linear</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalid_spline</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_make_spline</span><span class="p">()</span>

            <span class="c1"># ext = 1 is setting to 0. We set fill_value to 0, so this is the</span>
            <span class="c1"># default behavior. We change the bounds_error attribute in</span>
            <span class="c1"># RegularGridInterpolator that controls this. By default, we set it</span>
            <span class="c1"># to raise an error. We reset it to True when we are done.</span>
            <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spline_real</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spline_imag</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">def</span> <span class="nf">apply_spline</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
                <span class="n">y_real</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline_real</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                    <span class="n">y_imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spline_imag</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">y_real</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">y_imag</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">y_real</span>
                <span class="k">return</span> <span class="n">ret</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="n">apply_spline</span><span class="p">(</span><span class="n">x_arr</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spline_real</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spline_imag</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Now we have to reconstruct the correct return shape.</span>
        <span class="c1"># First, we determine what is the dimensionality of the output</span>
        <span class="c1"># of function</span>
        <span class="n">shape_function_return</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># And append this to the shape of the points</span>
        <span class="n">ret_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">points_shape</span> <span class="o">+</span> <span class="n">shape_function_return</span><span class="p">)</span>
        <span class="c1"># Finally, we reshape</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># TODO (FEATURE): Avoid splines when the data is already available.</span>
        <span class="c1">#</span>
        <span class="c1"># At the moment, the splines are calculated even on points in which</span>
        <span class="c1"># data is available. This is probably inefficient.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_with_spline</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="UniformGridData.sliced"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.sliced">[docs]</a>    <span class="k">def</span> <span class="nf">sliced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.UniformGridData` obtained slicing the current one.</span>

<span class="sd">        ``cut`` specifies how to slice the data. It has to be an array with the</span>
<span class="sd">        same number of dimensions of the data. In the entries where ``cut`` is</span>
<span class="sd">        None, that dimension is kept, where it is a number, the data is cut</span>
<span class="sd">        fixing that coordinate. For example, for a 2D array, if ``cut`` is</span>
<span class="sd">        ``[None, 2]``, the cut will be with ``y = 2``.</span>

<span class="sd">        If ``resample`` is True, you can cut at any point and we will compute</span>
<span class="sd">        the values with multilinear interpolation. If ``resample`` is False, we</span>
<span class="sd">        will use the data already available.</span>

<span class="sd">        In doing this, dimensions that are only one grid point are lost.</span>

<span class="sd">        :param cut: How to slice the array. None entries mean &quot;keep that dimension&quot;.</span>
<span class="sd">        :type cut:  array or list with dimension</span>
<span class="sd">        :param resample: Whether to use multilinear interpolation to compute the</span>
<span class="sd">                         data or simply use the value of the closest point.</span>
<span class="sd">        :type resample: bool</span>

<span class="sd">        :returns: A sliced :py:class:`~.UniformGridData`.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO (REFACTORING): Don&#39;t repet yourself!</span>
        <span class="c1">#</span>
        <span class="c1"># There is redundancy in how this function is written. It should be easy</span>
        <span class="c1"># to simplify it.</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cut</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cut</span><span class="si">}</span><span class="s2"> has wrong dimension. Cut has to have the same&quot;</span>
                <span class="s2">&quot; dimensions as the grid, and has to have None on the&quot;</span>
                <span class="s2">&quot; dimension you want to keep&quot;</span>
            <span class="p">)</span>

        <span class="c1"># First we check that we actually have to resample and cut is not all</span>
        <span class="c1"># None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cut</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">cut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># If we have to resample, we simply prepare a new UniformGrid with the</span>
        <span class="c1"># coordiantes that we want. We are going to resample keeping the number</span>
        <span class="c1"># of dimensions fixed, but setting shape of 1 grid point on those</span>
        <span class="c1"># dimensions that have to be cut. Then, we flatten the UniformGridData</span>
        <span class="c1"># (which removes dimensions with one grid point).</span>

        <span class="k">if</span> <span class="n">resample</span><span class="p">:</span>
            <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">new_x0</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">new_ghost</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="n">new_grid</span> <span class="o">=</span> <span class="n">UniformGrid</span><span class="p">(</span>
                <span class="n">new_shape</span><span class="p">,</span>
                <span class="n">x0</span><span class="o">=</span><span class="n">new_x0</span><span class="p">,</span>
                <span class="n">dx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span>
                <span class="n">ref_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span>
                <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">,</span>
                <span class="n">num_ghost</span><span class="o">=</span><span class="n">new_ghost</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                <span class="n">iteration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># We used &quot;resampled&quot; to make a copy, then &quot;flat_dimensions_remove&quot;</span>
            <span class="c1"># to modify that (so that we don&#39;t make a new copy)</span>
            <span class="n">sliced_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">(</span><span class="n">new_grid</span><span class="p">)</span>
            <span class="n">sliced_data</span><span class="o">.</span><span class="n">flat_dimensions_remove</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">sliced_data</span>

        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="n">new_x0</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="n">new_dx</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="n">new_ghost</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">]</span>

        <span class="n">new_grid</span> <span class="o">=</span> <span class="n">UniformGrid</span><span class="p">(</span>
            <span class="n">new_shape</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="n">new_x0</span><span class="p">,</span>
            <span class="n">dx</span><span class="o">=</span><span class="n">new_dx</span><span class="p">,</span>
            <span class="n">ref_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span>
            <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">,</span>
            <span class="n">num_ghost</span><span class="o">=</span><span class="n">new_ghost</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="n">iteration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Here we are not resampling, so we just have to properly cut the array.</span>
        <span class="c1"># We prepare a slicer array which defines where to cut.</span>
        <span class="n">slicer</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># We walk through all the dimensions, if some unreasonable cuts are</span>
        <span class="c1"># requsted, we throw an error, otherwise we find the index of the</span>
        <span class="c1"># data element where to cut.</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">slicer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">lowest_vertex</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                    <span class="o">&lt;=</span> <span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                    <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">highest_vertex</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="c1"># The slice method in HierarchicalGridData matches this</span>
                    <span class="c1"># error message, so you change it, update the corresponding</span>
                    <span class="c1"># method.</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cut point is outside the grid&quot;</span><span class="p">)</span>
                <span class="c1"># Transform from coordinate to index</span>
                <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">cut</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
                <span class="n">slicer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="n">slicer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slicer</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">slicer</span><span class="p">])</span></div>

<div class="viewcode-block" id="UniformGridData.slice"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.slice">[docs]</a>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice the data along given direction.</span>

<span class="sd">        ``cut`` specifies how to slice the data. It has to be an array with the</span>
<span class="sd">        same number of dimensions of the data. In the entries where ``cut`` is</span>
<span class="sd">        None, that dimension is kept, where it is a number, the data is cut</span>
<span class="sd">        fixing that coordinate. For example, for a 2D array, if ``cut`` is</span>
<span class="sd">        ``[None, 2]``, the cut will be with ``y = 2``.</span>

<span class="sd">        If ``resample`` is True, you can cut at any point and we will compute</span>
<span class="sd">        the values with multilinear interpolation. If ``resample`` is False, we</span>
<span class="sd">        will use the data already available.</span>

<span class="sd">        In doing this, dimensions that are only one grid point are lost.</span>

<span class="sd">        :param cut: How to slice the array. None entries mean &quot;keep that dimension&quot;.</span>
<span class="sd">        :type cut:  array or list with dimension</span>
<span class="sd">        :param resample: Whether to use multilinear interpolation to compute the</span>
<span class="sd">                         data or simply use the value of the closest point.</span>
<span class="sd">        :type resample: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sliced</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="n">cut</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.resampled"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.resampled">[docs]</a>    <span class="k">def</span> <span class="nf">resampled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_grid</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.UniformGridData` resampled to ``new_grid``.</span>

<span class="sd">        If you want to resample without using the spline, and you want a nearest</span>
<span class="sd">        neighbor resampling, pass the keyword ``piecewise_constant=True``. This</span>
<span class="sd">        may be a good choice for data with large discontinuities, where the</span>
<span class="sd">        splines are ineffective.</span>

<span class="sd">        :param new_grid: New independent variable.</span>
<span class="sd">        :type new_grid:  1D NumPy array or list of float</span>
<span class="sd">        :param ext: How to handle points outside the data interval.</span>
<span class="sd">        :type ext: 1 for returning zero, 2 for ``ValueError``,</span>
<span class="sd">        :param piecewise_constant: Do not use splines, use the nearest neighbors.</span>
<span class="sd">        :type piecewise_constant: bool</span>
<span class="sd">        :returns: Resampled data.</span>
<span class="sd">        :rtype:   :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_grid</span><span class="p">,</span> <span class="n">UniformGrid</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Resample takes another UniformGrid&quot;</span><span class="p">)</span>

        <span class="c1"># If grid is the same, there&#39;s no need to resample</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">==</span> <span class="n">new_grid</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
            <span class="n">new_grid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_with_spline</span><span class="p">(</span>
                <span class="n">new_grid</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="n">piecewise_constant</span>
            <span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.is_complex"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.is_complex">[docs]</a>    <span class="k">def</span> <span class="nf">is_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the data is complex.</span>

<span class="sd">        :returns:  True if the data is complex, false if it is not.</span>
<span class="sd">        :rtype:   bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span>

    <span class="k">def</span> <span class="nf">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the method ``f`` to ``self``, modifying ``self``.</span>

<span class="sd">        This function is used to implement those methods that act on the object</span>
<span class="sd">        starting from methods that return a new object. The function has to</span>
<span class="sd">        return a new copy of the object (not a reference).</span>

<span class="sd">        :param f: Method to apply.</span>
<span class="sd">        :type f: callable</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">ret</span><span class="o">.</span><span class="n">data</span>
        <span class="c1"># We have to recompute the splines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalid_spline</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="UniformGridData.flat_dimensions_removed"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.flat_dimensions_removed">[docs]</a>    <span class="k">def</span> <span class="nf">flat_dimensions_removed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.UniformGridData` with dimensions of one grid point</span>
<span class="sd">        removed.</span>

<span class="sd">        :returns: New :py:class:`UniformGridData` without flat dimensions.</span>
<span class="sd">        :rtype: :py:class:`UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">flat_dimensions_removed</span><span class="p">()</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_grid</span><span class="p">,</span> <span class="n">new_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.flat_dimensions_remove"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.flat_dimensions_remove">[docs]</a>    <span class="k">def</span> <span class="nf">flat_dimensions_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove dimensions which are only one gridpoint large.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flat_dimensions_removed</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.ghost_zones_removed"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.ghost_zones_removed">[docs]</a>    <span class="k">def</span> <span class="nf">ghost_zones_removed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`UniformGridData` with all the ghost zones removed.</span>

<span class="sd">        :returns: New :py:class:`UniformGridData` without ghostzones.</span>
<span class="sd">        :rtype: :py:class:`UniformGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">new_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">ghost_zones_removed</span><span class="p">()</span>
        <span class="c1"># We remove the borders from the data using the slicing operator</span>
        <span class="n">slicer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="nb">slice</span><span class="p">(</span><span class="n">ghost_zones</span><span class="p">,</span> <span class="o">-</span><span class="n">ghost_zones</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ghost_zones</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_grid</span><span class="p">,</span> <span class="n">new_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.ghost_zones_remove"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.ghost_zones_remove">[docs]</a>    <span class="k">def</span> <span class="nf">ghost_zones_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all the ghost zones.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ghost_zones_removed</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.dx_changed"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.dx_changed">[docs]</a>    <span class="k">def</span> <span class="nf">dx_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dx</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`UniformGridData` with the same grid extent, but with</span>
<span class="sd">        a new spacing. This effectively up-samples or down-samples the grid.</span>

<span class="sd">        Missing data is obtained with splines.</span>

<span class="sd">        ``new_dx`` has to be an integer multiple of the current ``dx`` (or vice</span>
<span class="sd">        versa).</span>

<span class="sd">        If ``piecewise_constant=True``, the missing information is obtained with</span>
<span class="sd">        from the nearest neighbors.</span>

<span class="sd">        :param new_dx: Do not use splines, use the nearest neighbors.</span>
<span class="sd">        :type new_dx: 1d NumPy array</span>
<span class="sd">        :param piecewise_constant: Do not use splines, use the nearest neighbors.</span>
<span class="sd">        :type piecewise_constant: bool</span>

<span class="sd">        :returns: Data with new grid spacing ``new_dx``.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">new_dx</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;dx has to be a list or an array. </span><span class="si">{</span><span class="n">new_dx</span><span class="si">}</span><span class="s2"> is not&quot;</span>
            <span class="p">)</span>

        <span class="c1"># First, we check that new_dx is and dx are compatible</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_dx</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Provided dx has not the correct number of dimensions&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If we don&#39;t have to change dx, just return a copy</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">new_dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">new</span> <span class="o">/</span> <span class="n">old</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">old</span> <span class="o">/</span> <span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Provided dx is not an integer multiple or factor of current dx&quot;</span>
                <span class="p">)</span>

        <span class="c1"># new_dx can have zero entries, for which a shape of 1 should correspond.</span>
        <span class="c1"># There can zero entries, we substitute them with -1, so that we</span>
        <span class="c1"># can identify them as negative numbers</span>
        <span class="n">new_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx</span> <span class="k">if</span> <span class="n">dx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">new_dx</span><span class="p">])</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="n">new_dx</span> <span class="o">+</span> <span class="mf">1.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span> <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new_shape</span><span class="p">])</span>

        <span class="n">new_grid</span> <span class="o">=</span> <span class="n">UniformGrid</span><span class="p">(</span>
            <span class="n">new_shape</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span>
            <span class="n">dx</span><span class="o">=</span><span class="n">new_dx</span><span class="p">,</span>
            <span class="n">ref_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span>
            <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">,</span>
            <span class="n">num_ghost</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="n">iteration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">(</span><span class="n">new_grid</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="n">piecewise_constant</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.dx_change"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.dx_change">[docs]</a>    <span class="k">def</span> <span class="nf">dx_change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dx</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Up-samples or down-samples the grid data.</span>

<span class="sd">        Missing data is obtained with splines.</span>

<span class="sd">        ``new_dx`` has to be an integer multiple of the current ``dx`` (or vice</span>
<span class="sd">        versa).</span>

<span class="sd">        If ``piecewise_constant=True``, the missing information is obtained with</span>
<span class="sd">        from the nearest neighbors.</span>

<span class="sd">        :param new_dx: Do not use splines, use the nearest neighbors.</span>
<span class="sd">        :type new_dx: 1d NumPy array</span>
<span class="sd">        :param piecewise_constant: Do not use splines, use the nearest neighbors.</span>
<span class="sd">        :type piecewise_constant: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dx_changed</span><span class="p">,</span> <span class="n">new_dx</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="n">piecewise_constant</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.copy"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a deep of self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of dimensions of the grid.</span>

<span class="sd">        :returns: Number of dimensions of the grid.</span>
<span class="sd">        :rtype:   float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">num_dimensions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_extended_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of dimensions with size larger than one gridpoint.</span>

<span class="sd">        :returns: The number of extended dimensions (the ones with more than one cell).</span>
<span class="sd">        :rtype:   int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">num_extended_dimensions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">extended_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an array of bools with whether a dimension has more than one</span>
<span class="sd">        point or not.</span>

<span class="sd">        :returns: Dimensions with more than one point.</span>
<span class="sd">        :rtype:   1d NumPy of bools</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">extended_dimensions</span>

<div class="viewcode-block" id="UniformGridData.integral"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.integral">[docs]</a>    <span class="k">def</span> <span class="nf">integral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the integral over the whole volume of the grid.</span>

<span class="sd">        :returns: The integral computed as volume-weighted sum.</span>
<span class="sd">        :rtype:   float (or complex if data is complex).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dv</span></div>

<div class="viewcode-block" id="UniformGridData.mean"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the mean of the data over the whole volume of the grid.</span>

<span class="sd">        :returns: Arithmetic mean of the data.</span>
<span class="sd">        :rtype:   float (or complex if data is complex).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>

    <span class="n">average</span> <span class="o">=</span> <span class="n">mean</span>

<div class="viewcode-block" id="UniformGridData.norm_p"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.norm_p">[docs]</a>    <span class="k">def</span> <span class="nf">norm_p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the norm of order ``p`` over the whole volume of the grid.</span>

<span class="sd">        :math:`\|u\|_p = (\sum \|u\|^p dv)^1/p`</span>

<span class="sd">        :param order: Order of the norm.</span>
<span class="sd">        :type order: int</span>

<span class="sd">        :returns: The norm2 computed as volume-weighted sum.</span>
<span class="sd">        :rtype:   float (or complex if data is complex).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="nb">ord</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dv</span> <span class="o">**</span> <span class="p">(</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="n">order</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.norm2"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.norm2">[docs]</a>    <span class="k">def</span> <span class="nf">norm2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the norm over the whole volume of the grid.</span>

<span class="sd">        :math:`\|u\|_2 = (\sum \|u\|^2 dv)^1/2`</span>

<span class="sd">        :returns: The norm2 computed as volume-weighted sum.</span>
<span class="sd">        :rtype:   float (or complex if data is complex).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_p</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.norm1"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.norm1">[docs]</a>    <span class="k">def</span> <span class="nf">norm1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the norm over the whole volume of the grid.</span>

<span class="sd">        :math:`\|u\|_1 = \sum \|u\| dv`</span>

<span class="sd">        :returns: The norm2 computed as volume-weighted sum.</span>
<span class="sd">        :rtype:   float (or complex if data is complex).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_p</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.histogram"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.histogram">[docs]</a>    <span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">min_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">num_bins</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the 1D Histogram of the data.</span>

<span class="sd">        :param weights:    The weight for each cell. Default is one.</span>
<span class="sd">        :type weights:     :py:class:`~.UniformGridData` or NumPy array of same shape or None.</span>
<span class="sd">        :param min_value: Lower bound of data to consider. Default is data range.</span>
<span class="sd">        :type min_value: float or None</span>
<span class="sd">        :param max_value: Upper bound of data to consider. Default is data range.</span>
<span class="sd">        :type max_value: float or None</span>
<span class="sd">        :param num_bins: Number of bins to create.</span>
<span class="sd">        :type num_bins: int &gt; 1</span>

<span class="sd">        :returns: The positions of the data bins and the distribution.</span>
<span class="sd">        :rtype:   tuple of two 1D NumPy arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Histogram only works with real data&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">UniformGridData</span><span class="p">):</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Check that we have a NumPy array or None</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Weights has to be a UniformGrid, NumPy array or None&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="p">),</span>
            <span class="n">bins</span><span class="o">=</span><span class="n">num_bins</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.percentiles"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.percentiles">[docs]</a>    <span class="k">def</span> <span class="nf">percentiles</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fractions</span><span class="p">,</span>
        <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">relative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">min_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">num_bins</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find values for which a given fraction(s) of the data is smaller.</span>

<span class="sd">        Optionally, the cells can have an optional weight, and absolute counts</span>
<span class="sd">        can be used instead of fraction.</span>

<span class="sd">        :param fractions: List of fraction/absolute values.</span>
<span class="sd">        :type fractions:  list or array of floats</span>
<span class="sd">        :param weights:    The weight for each cell. Default is one.</span>
<span class="sd">        :type weights:     :py:class:`~.UniformGridData` or NumPy array of same shape or None.</span>
<span class="sd">        :param relative:   Whether fractions refer to relative or absolute count.</span>
<span class="sd">        :type relative:    bool</span>
<span class="sd">        :param min_value: Lower bound of data to consider. Default is data range.</span>
<span class="sd">        :type min_value: float or None</span>
<span class="sd">        :param max_value: Upper bound of data to consider. Default is data range.</span>
<span class="sd">        :type max_value: float or None</span>
<span class="sd">        :param num_bins:      Number of bins to create.</span>
<span class="sd">        :type num_bins:       integer &gt; 1</span>

<span class="sd">        :returns: Data values corresponding to the given fractions.</span>
<span class="sd">        :rtype:   1D NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hist_values</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
            <span class="n">min_value</span><span class="o">=</span><span class="n">min_value</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">max_value</span><span class="p">,</span>
            <span class="n">num_bins</span><span class="o">=</span><span class="n">num_bins</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">hist_cumulative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hist_values</span><span class="p">)</span>

        <span class="c1"># So that the last element is 1</span>
        <span class="k">if</span> <span class="n">relative</span><span class="p">:</span>
            <span class="c1"># We need to make sure that the everything is float here,</span>
            <span class="c1"># otherwise NumPy complains</span>
            <span class="n">hist_cumulative</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">hist_cumulative</span>
            <span class="n">hist_cumulative</span> <span class="o">/=</span> <span class="n">hist_cumulative</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># We remove the first point because all the data is larger than that.</span>
        <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># So that we can use it as an array</span>
        <span class="n">fractions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fractions</span><span class="p">)</span>

        <span class="c1"># We must make sure that fractions is not larger than the amount of data</span>
        <span class="c1"># (or of 1, in the case of normalized histogram). If input fraction is</span>
        <span class="c1"># larger than 1, the output must be 100 % of the data anyways.</span>
        <span class="c1">#</span>
        <span class="c1"># We make sure that this is at least 1d so that we can loop over it</span>
        <span class="n">capped_fractions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">hist_cumulative</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fractions</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Here we return the first element of the array bin edges that is larger</span>
        <span class="c1"># than each element in capped_fractions</span>
        <span class="n">percentiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">hist_cumulative</span> <span class="o">&gt;=</span> <span class="n">f</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">capped_fractions</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">percentiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">percentiles</span></div>

<div class="viewcode-block" id="UniformGridData.partial_derived"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.partial_derived">[docs]</a>    <span class="k">def</span> <span class="nf">partial_derived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :py:class:`~.UniformGridData` that is the numerical</span>
<span class="sd">        order-differentiation of the present grid_data along a given direction.</span>
<span class="sd">        (``order`` = number of derivatives, ie ``order=2`` is second derivative)</span>

<span class="sd">        The derivative is calulated as centered differencing in the interior</span>
<span class="sd">        and one-sided derivatives at the boundaries. Higher orders are computed</span>
<span class="sd">        applying the same rule recursively.</span>

<span class="sd">        The output has the same shape of ``self``.</span>

<span class="sd">        :param order: Order of derivative (e.g. 2 = second derivative).</span>
<span class="sd">        :type order: int</span>
<span class="sd">        :param direction: Direction of the partial derivative.</span>
<span class="sd">        :type direction: int</span>

<span class="sd">        :returns:  New :py:class:`~.UniformGridData` with derivative.</span>
<span class="sd">        :rtype:    :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">direction</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Grid has </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="si">}</span><span class="s2">, dimensions, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2"> is not available&quot;</span>
            <span class="p">)</span>

        <span class="n">ret_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_num_deriv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>

            <span class="n">ret_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span>
                <span class="n">ret_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">direction</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">ret_value</span><span class="p">)</span></div>

<div class="viewcode-block" id="UniformGridData.gradient"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.gradient">[docs]</a>    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list :py:class:`~.UniformGridData` that are the numerical</span>
<span class="sd">        order-differentiation of the present grid_data along all the directions.</span>
<span class="sd">        (``order`` = number of derivatives, ie ``order=2`` is second derivative)</span>

<span class="sd">        The derivative is calulated as centered differencing in the interior</span>
<span class="sd">        and one-sided derivatives at the boundaries. Higher orders are computed</span>
<span class="sd">        applying the same rule recursively.</span>

<span class="sd">        The output has the same shape of ``self``.</span>

<span class="sd">        :param order: Order of derivative (e.g. 2 = second derivative).</span>
<span class="sd">        :type order: int</span>
<span class="sd">        :param direction: Direction of the partial derivative.</span>
<span class="sd">        :type direction: int</span>
<span class="sd">        :returns:  list of :py:class:`~.UniformGridData` with partial derivative</span>
<span class="sd">                   along the directions.</span>
<span class="sd">        :rtype:    list of :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partial_derived</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="UniformGridData.partial_derive"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.partial_derive">[docs]</a>    <span class="k">def</span> <span class="nf">partial_derive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Derive the data with numerical finite difference along a given direction</span>
<span class="sd">        (``order`` = number of derivatives, ie ``order=2`` is second derivative).</span>

<span class="sd">        The derivative is calulated as centered differencing in the interior</span>
<span class="sd">        and one-sided derivatives at the boundaries. Higher orders are computed</span>
<span class="sd">        applying the same rule recursively.</span>

<span class="sd">        The output has the same shape of ``self``.</span>

<span class="sd">        :param order: Order of derivative (e.g. 2 = second derivative).</span>
<span class="sd">        :type order: int</span>
<span class="sd">        :param direction: Direction of the partial derivative.</span>
<span class="sd">        :type direction: int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partial_derived</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_apply_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a unary function to the data.</span>

<span class="sd">        :param function: Unary function.</span>
<span class="sd">        :type function:  callable</span>
<span class="sd">        :returns: Function applied to the data.</span>
<span class="sd">        :rtype:    :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_apply_reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a reduction to the data.</span>

<span class="sd">        :param function: Function to apply to the data.</span>
<span class="sd">        :type function: callable</span>

<span class="sd">        :return: Reduction applied to the data.</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">reduction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_binary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is an abstract function that is used to implement mathematical</span>
<span class="sd">        operations with other :py:class:`~.UniformGridData` (if they have the</span>
<span class="sd">        same grid) or scalars.</span>

<span class="sd">        _apply_binary takes another object that can be of the same type or a</span>
<span class="sd">        scalar, and applies function(self.data, other.data), performing type</span>
<span class="sd">        checking.</span>

<span class="sd">        :param other: Other object.</span>
<span class="sd">        :type other: :py:class:`~.UniformGridData` or scalar</span>
<span class="sd">        :param function: Dyadic function.</span>
<span class="sd">        :type function: callable</span>

<span class="sd">        :returns:  Return value of function when called with ``self`` and ``other``.</span>
<span class="sd">        :rtype:    :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the other object is of the same type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="c1"># Check the the coordinates are the same by checking shape, origin</span>
            <span class="c1"># and dx</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The objects do not have the same grid!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

        <span class="c1"># If it is a number</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

        <span class="c1"># If we are here, it is because we cannot add the two objects</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;I don&#39;t know how to combine these objects&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span>
        <span class="p">)</span>

<div class="viewcode-block" id="UniformGridData.fourier_transform"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.UniformGridData.fourier_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fourier_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform the multi-dimensional Fourier transform on the data.</span>

<span class="sd">        We follow NumPy&#39;s conventions, with the exception that we normalize the</span>
<span class="sd">        amplitude with ``dx``.</span>

<span class="sd">        If the signal is complex, we also shift the negative components to be in</span>
<span class="sd">        the negative part of the signal.</span>

<span class="sd">        :returns: Fourier transform.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fft_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
        <span class="c1"># We extract the frequencies along each direction</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">dim</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">):</span>
            <span class="n">fft_data</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="n">lowest_freqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">freqs</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)]</span>
        <span class="n">delta_freqs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">freqs</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="n">UniformGrid</span><span class="p">(</span>
            <span class="n">fft_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="n">lowest_freqs</span><span class="p">,</span>
            <span class="n">dx</span><span class="o">=</span><span class="n">delta_freqs</span><span class="p">,</span>
            <span class="n">ref_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span>
            <span class="n">component</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">component</span><span class="p">,</span>
            <span class="n">num_ghost</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ghost</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="n">iteration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">grid</span><span class="p">,</span> <span class="n">fft_data</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="HierarchicalGridData"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData">[docs]</a><span class="k">class</span> <span class="nc">HierarchicalGridData</span><span class="p">(</span><span class="n">BaseNumerical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents data defined on mesh-refined grids, consisting of one or more</span>
<span class="sd">    regular datasets with different grid spacings.</span>

<span class="sd">    All the arithmetic operations and binary operators are defined for this</span>
<span class="sd">    class, as well as interpolation and resampling.</span>

<span class="sd">    Upon initialization, we try to merge together all the components (output</span>
<span class="sd">    from different MPI processes), so there is one :py:class:`~.UniformGridData`</span>
<span class="sd">    per refinement level. In case of grids with more than one center of</span>
<span class="sd">    refinement, this is currently not possible, so we keep all the components</span>
<span class="sd">    around. In this, ghost zone information may be discarded.</span>

<span class="sd">    :ivar grid_data_dict: Mapping between refinement levels and components at</span>
<span class="sd">                          that refinement level.</span>
<span class="sd">    :type grid_data_dict: dict of :py:class:`~.UniformGridData`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uniform_grid_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        Here we try to merge the different components, if we can.</span>

<span class="sd">        :param uniform_grid_data: List of regular datasets.</span>
<span class="sd">        :type uniform_grid_data:  list of :py:class:`~.UniformGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">uniform_grid_data</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is built with list &quot;</span>
                <span class="s2">&quot;of UniformGridData&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniform_grid_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot create an empty </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">UniformGridData</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">uniform_grid_data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> requires a list of UniformGridData&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="n">d</span><span class="o">.</span><span class="n">num_dimensions</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">uniform_grid_data</span><span class="p">})</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimensionality mismatch&quot;</span><span class="p">)</span>

        <span class="c1"># Let&#39;s sort as increasing refinement level and component</span>
        <span class="n">uniform_grid_data_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">uniform_grid_data</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">component</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">components</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">uniform_grid_data_sorted</span><span class="p">:</span>
            <span class="n">components</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">ref_level</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">ref_level</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_merge_components</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">comps</span> <span class="ow">in</span> <span class="n">components</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_fill_grid_with_components</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">components</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a grid, try to fill it with the components, returning a</span>
<span class="sd">        :py:class:`~.UniformGridData` and the indices that actually were used in</span>
<span class="sd">        filling the grid.</span>

<span class="sd">        This happens by iterating over the components and copying data to the</span>
<span class="sd">        output grid, recording what points were filled. We also return the indices</span>
<span class="sd">        of the points that were filled.</span>

<span class="sd">        :param grid: Grid to fill.</span>
<span class="sd">        :type grid: :py:class:`~.UniformGrid`</span>
<span class="sd">        :param components: Components to fill the grid.</span>
<span class="sd">        :type components: list of :py:class:`~.UniformGridData`</span>

<span class="sd">        :returns: Merged components and indices used to merge the components.</span>
<span class="sd">        :rtype: tuple of :py:class:`~.UniformGridData` and numpy array</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># For filling the data, we prepare the array first, and we fill it with</span>
        <span class="c1"># the single components. We fill a second array which we use to keep</span>
        <span class="c1"># track of what indices have been filled with the input data.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">indices_used</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
            <span class="c1"># We find the index corresponding to x0 and x1 of the component</span>
            <span class="n">index_x0</span> <span class="o">=</span> <span class="p">((</span><span class="n">comp</span><span class="o">.</span><span class="n">x0</span> <span class="o">-</span> <span class="n">grid</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="n">grid</span><span class="o">.</span><span class="n">dx</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">index_x1</span> <span class="o">=</span> <span class="n">index_x0</span> <span class="o">+</span> <span class="n">comp</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">slicer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="nb">slice</span><span class="p">(</span><span class="n">index_j0</span><span class="p">,</span> <span class="n">index_j1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">index_j0</span><span class="p">,</span> <span class="n">index_j1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index_x0</span><span class="p">,</span> <span class="n">index_x1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">data</span>
            <span class="n">indices_used</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">UniformGridData</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">data</span><span class="p">),</span> <span class="n">indices_used</span>

    <span class="k">def</span> <span class="nf">_try_merge_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">components</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to merge a list of :py:class:`~.UniformGridData` instances into one,</span>
<span class="sd">        assuming they all have the same grid spacing and filling a regular grid</span>
<span class="sd">        completely.</span>

<span class="sd">        If the assumption is not verified, and some blank spaces are found, then</span>
<span class="sd">        it returns the input untouched. This happens in the case that there are</span>
<span class="sd">        multiple refinement centers, or if there are missing components.</span>

<span class="sd">        This function always returns a list, even when the components are merged.</span>
<span class="sd">        In that case, the return value is a ``[merged]``, where ``merged`` is a</span>
<span class="sd">        :py:class:`~.UniformGridData`.</span>

<span class="sd">        :param components: List of components.</span>
<span class="sd">        :type components: list of :py:class:`~.UniformGridData`</span>

<span class="sd">        :returns: List of components, or list with one single element, the merged</span>
<span class="sd">                  components.</span>
<span class="sd">        :rtype: list of :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ghost_zones_removed</span><span class="p">()]</span>

        <span class="c1"># TODO: Instead of throwing away the ghost zones, we should check them</span>

        <span class="c1"># We remove all the ghost zones so that we can arrange all the grids</span>
        <span class="c1"># one next to the other without having to worry about the overlapping</span>
        <span class="c1"># regions</span>
        <span class="n">components_no_ghosts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">ghost_zones_removed</span><span class="p">()</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">components</span>
        <span class="p">]</span>

        <span class="c1"># For convenience, we also order the components from the one with the</span>
        <span class="c1"># smallest x0 to the largest, so that we can easily find the</span>
        <span class="c1"># coordinates.</span>
        <span class="c1">#</span>
        <span class="c1"># We have to transform x.x0 in tuple because we cannot compare NumPy</span>
        <span class="c1"># arrays directly for sorting.</span>
        <span class="n">components_no_ghosts</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">x0</span><span class="p">))</span>

        <span class="c1"># Next, we prepare the global grid</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">gdu</span><span class="o">.</span><span class="n">merge_uniform_grids</span><span class="p">(</span>
            <span class="p">[</span><span class="n">comp</span><span class="o">.</span><span class="n">grid</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">components_no_ghosts</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">merged_grid_data</span><span class="p">,</span> <span class="n">indices_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_grid_with_components</span><span class="p">(</span>
            <span class="n">grid</span><span class="p">,</span> <span class="n">components_no_ghosts</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">indices_used</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">merged_grid_data</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">components</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of components at the given refinement level.</span>

<span class="sd">        You can also consider using :py:meth:`~.get_level`, which returns a</span>
<span class="sd">        single :py:class:`~.UniformGridData` if there&#39;s only one component at</span>
<span class="sd">        that level (otherwise error).</span>

<span class="sd">        :param key: Refinement level.</span>
<span class="sd">        :type key: int</span>

<span class="sd">        :returns: List of components at a given refinement level.</span>
<span class="sd">        :rvalue: list of :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

<div class="viewcode-block" id="HierarchicalGridData.get_level"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.get_level">[docs]</a>    <span class="k">def</span> <span class="nf">get_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the data at a given refinement level.</span>

<span class="sd">        :param ref_level: Number of refinement level.</span>
<span class="sd">        :type ref_level: int</span>

<span class="sd">        :returns: Data at given refinement level.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ref_level</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Level </span><span class="si">{</span><span class="n">ref_level</span><span class="si">}</span><span class="s2"> not available&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ref_level</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Level </span><span class="si">{</span><span class="n">ref_level</span><span class="si">}</span><span class="s2"> has multiple patches&quot;</span>
                <span class="s2">&quot; get_level works only when there is one&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">ref_level</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="HierarchicalGridData.iter_from_finest"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.iter_from_finest">[docs]</a>    <span class="k">def</span> <span class="nf">iter_from_finest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterator over the components, sorted by refinement level, from the finest to</span>
<span class="sd">        the coarsest.</span>

<span class="sd">        :returns: Refinement level number, component index, and data.</span>
<span class="sd">        :rtype: generator of tuples (int, int, :py:class:`~.UniformGridData`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO (FUTURE): Reverse dictionary in Python 3.8</span>
        <span class="c1">#</span>
        <span class="c1"># In Python 3.8 we can reverse without transforming into a list first</span>
        <span class="k">for</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">())):</span>
            <span class="k">for</span> <span class="n">comp_index</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">comp_index</span><span class="p">,</span> <span class="n">comp</span></div>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate across all the refinement levels and components from the coarsest</span>
<span class="sd">        to the finest.</span>

<span class="sd">        :returns: Refinement level number, component index, and data.</span>
<span class="sd">        :rtype: tuple (int, int, :py:class:`~.UniformGridData`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">comp_index</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">comp_index</span><span class="p">,</span> <span class="n">comp</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">refinement_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list with the refinement levels available.</span>

<span class="sd">        :returns: List of refinement levels available.</span>
<span class="sd">        :rtype: list of ints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list with all the components.</span>

<span class="sd">        This is useful to create a new :py:class:`~.HierarchicalGridData`</span>
<span class="sd">        from ``self``.</span>

<span class="sd">        :returns: List of all the components.</span>
<span class="sd">        :rtype: list of :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_components</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comps</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">all_components</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_components</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_finest_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of the finest refinement level.</span>

<span class="sd">        :returns: Index of the finest level.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">finest_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the finest level, if it is a single grid.</span>

<span class="sd">        :returns: Finest level.</span>
<span class="sd">        :rtype: :py:class:`~UniformGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_level</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_finest_level</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_refinement_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of the finest refinement level.</span>

<span class="sd">        Alias for :py:meth:`~.num_finest_level`.</span>

<span class="sd">        :returns: Index of the finest level.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_finest_level</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_coarsest_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of the coarsest refinement level.</span>

<span class="sd">        :returns: Index of the coarsest level.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coarsest_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the coarsest level, if it is a single grid.</span>

<span class="sd">        :returns: Coarsest level.</span>
<span class="sd">        :rtype: :py:class:`~UniformGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_level</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_coarsest_level</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the first component of the coarsest refinement level.</span>

<span class="sd">        :returns: First component of the coarsest level.</span>
<span class="sd">        :rtype: `:py:class:~UniformGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_coarsest_level</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_component</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of components per each refinement level.</span>

<span class="sd">        For example, if data has three levels, with 1 component in the first, 2</span>
<span class="sd">        in the second, and three in the fifth, shape will be {1: 1, 2: 2, 5: 3}</span>

<span class="sd">        This method is useful for quick high level comparison between two</span>
<span class="sd">        :py:class:`~.HierachicalGridData`.</span>

<span class="sd">        :returns: Dictionary with keys the refinement level numbers and values the</span>
<span class="sd">                  number of components at that level.</span>
<span class="sd">        :rtype: dictionary</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">ref_level</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Origin of the coarsest grid, if it is a single component.</span>

<span class="sd">        :returns: Origin of the coarsest grid, if it is a single component.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We have multiple patches</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_coarsest_level</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Data does not have a well defined x0 &quot;</span>
                <span class="s2">&quot; (there are multiple patches)&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_component</span><span class="o">.</span><span class="n">x0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Corner of the coarsest grid, if it is a single component.</span>

<span class="sd">        :returns: Corner of the coarsest grid, if it is a single component.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We have multiple patches</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_coarsest_level</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Data does not have a well defined x1&quot;</span>
                <span class="s2">&quot; (there are multiple patches)&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_component</span><span class="o">.</span><span class="n">x1</span>

<div class="viewcode-block" id="HierarchicalGridData.dx_at_level"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.dx_at_level">[docs]</a>    <span class="k">def</span> <span class="nf">dx_at_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the grid spacing at the specified refinement level.</span>

<span class="sd">        :param level: Refinement level number.</span>
<span class="sd">        :type level: int</span>
<span class="sd">        :returns: Spacing at the given refinement level.</span>
<span class="sd">        :rtype: 1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">level</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dx</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coarsest_dx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the grid spacing of the coarsest level.</span>

<span class="sd">        :returns:  Grid spacing of the coarsest level.</span>
<span class="sd">        :rtype:   1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx_at_level</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_coarsest_level</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">finest_dx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the grid spacing of the finest level.</span>

<span class="sd">        :returns:  Grid spacing of the finest level.</span>
<span class="sd">        :rtype:   1d NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx_at_level</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_finest_level</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of dimensions.</span>

<span class="sd">        :returns:  Number of dimensions.</span>
<span class="sd">        :rtype:   int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_component</span><span class="o">.</span><span class="n">num_dimensions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_extended_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of dimensions with more than one cell.</span>

<span class="sd">        :returns:  Number of dimensions with more than one gridpoint.</span>
<span class="sd">        :rtype:   int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_component</span><span class="o">.</span><span class="n">num_extended_dimensions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The time of the coarsest refinement level.</span>

<span class="sd">        :returns:  Time of the coarsest refinement level.</span>
<span class="sd">        :rtype:   float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_component</span><span class="o">.</span><span class="n">time</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The iteration of the coarsest refinement level.</span>

<span class="sd">        :returns:  Iteration number of the coarsest refinement level.</span>
<span class="sd">        :rtype:   int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_component</span><span class="o">.</span><span class="n">iteration</span>

<div class="viewcode-block" id="HierarchicalGridData.copy"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a deep copy.</span>

<span class="sd">        :returns:  Deep copy of the :py:class:`~.HierarchicalGridData`.</span>
<span class="sd">        :rtype:    :py:class:`~.HierarchicalGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check for equality.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">HierarchicalGridData</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">all_components</span>

    <span class="k">def</span> <span class="nf">_finest_level_component_at_point_core</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number and the component index of the most refined level that</span>
<span class="sd">        contains the given coordinate assuming a valid input coordinate.</span>

<span class="sd">        :param coordinate: Point.</span>
<span class="sd">        :type coordinate: tuple or NumPy array with the same dimension</span>

<span class="sd">        :returns: Most refined level (and component) that contains the</span>
<span class="sd">        coordinate.</span>
<span class="sd">        :rtype: tuple of ints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We walk from the finest level to the coarsest. If we find the point,</span>
        <span class="c1"># re return it. If we find nothing, we raise error.</span>
        <span class="k">for</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">grid_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_from_finest</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">coordinate</span> <span class="ow">in</span> <span class="n">grid_data</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">coordinate</span><span class="si">}</span><span class="s2"> outside the grid&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="HierarchicalGridData.finest_level_component_at_point"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.finest_level_component_at_point">[docs]</a>    <span class="k">def</span> <span class="nf">finest_level_component_at_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number and the component index of the most</span>
<span class="sd">        refined level that contains the given coordinate.</span>

<span class="sd">        :param coordinate: Point.</span>
<span class="sd">        :type coordinate: tuple or NumPy array with the same dimension</span>

<span class="sd">        :returns: Most refined level (and component) that contains the</span>
<span class="sd">                  coordinate.</span>
<span class="sd">        :rtype: tuple of ints</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">coordinate</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">coordinate</span><span class="si">}</span><span class="s2"> is not a valid point&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The input point has dimension </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; but the data has dimension </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finest_level_component_at_point_core</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.evaluate_with_spline"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.evaluate_with_spline">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_with_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the spline on the points ``x``.</span>

<span class="sd">        Values outside the interval are set to 0 if ext=1, or a ``ValueError``</span>
<span class="sd">        is raised if ``ext=2``.</span>

<span class="sd">        This method is meant to be used only if you want to use a different</span>
<span class="sd">        ``ext`` for a specific call, otherwise, just use __call__.</span>

<span class="sd">        :param x: Points where to evaluate the data.</span>
<span class="sd">        :type x: 1D NumPy array of float, or :py:class:`~.UniformGrid`</span>

<span class="sd">        :param ext: How to deal values outside the bounaries. Values outside</span>
<span class="sd">                    the interval are set to 0 if ``ext=1``,</span>
<span class="sd">                    or an error is raised if ``ext=2``.</span>
<span class="sd">        :type ext:  int</span>

<span class="sd">        :returns: Values of the data evaluated on the input ``x``.</span>
<span class="sd">        :rtype:   1D NumPy array or float</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">UniformGrid</span><span class="p">):</span>
            <span class="c1"># The way we want the coordinates is like as an array with the same</span>
            <span class="c1"># shape of the grid and with values the coordinates (as arrays). This</span>
            <span class="c1"># is similar to as_same_shape, but the coordinates have to be the</span>
            <span class="c1"># value, and not the first index.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">as_same_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># We flatten the array (up to the last dimension) and we save the</span>
        <span class="c1"># original shape, because we are going to reshape it at the end.</span>
        <span class="n">points_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">original_shape</span> <span class="o">=</span> <span class="n">points_arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">points_arr</span> <span class="o">=</span> <span class="n">points_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">points_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># NOTE: The following algorithm is not the fastest but it doesn&#39;t matter</span>
        <span class="c1">#       too much because UniformGridData.evaluate_with_spline dominates</span>
        <span class="c1">#       the execution time.</span>

        <span class="c1"># Next, we organize points depending on the component/refinement level</span>
        <span class="c1"># they belong.</span>
        <span class="c1">#</span>
        <span class="c1"># level_comps is a dictionary with keys the refinement levels and</span>
        <span class="c1"># components for which we have to compute points and for values a list</span>
        <span class="c1"># with the index of the points in points_arr. We need the indices because</span>
        <span class="c1"># we need to put back the values where they were, since we are going to</span>
        <span class="c1"># take bit and pieces of the array.</span>
        <span class="n">level_comps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points_arr</span><span class="p">):</span>
            <span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finest_level_component_at_point_core</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="n">level_comps</span><span class="o">.</span><span class="n">setdefault</span><span class="p">((</span><span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span><span class="p">),</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># Now, we can evaluate the points using the methods of UniformGridData.</span>
        <span class="c1"># We collect all results in a new array that is initially full of zeros</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points_arr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span><span class="p">),</span> <span class="n">points_indices</span> <span class="ow">in</span> <span class="n">level_comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">points_arr</span><span class="p">[</span><span class="n">level_comps</span><span class="p">[</span><span class="n">ref_level</span><span class="p">,</span> <span class="n">comp</span><span class="p">]]</span>
            <span class="n">evaluated_points</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ref_level</span><span class="p">][</span><span class="n">comp</span><span class="p">]</span><span class="o">.</span><span class="n">evaluate_with_spline</span><span class="p">(</span>
                <span class="n">points</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="n">piecewise_constant</span>
            <span class="p">)</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">points_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">evaluated_points</span>

        <span class="c1"># Finally, we have to reshape the array to the correct form.</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_with_spline</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="HierarchicalGridData.to_UniformGridData_from_grid"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.to_UniformGridData_from_grid">[docs]</a>    <span class="k">def</span> <span class="nf">to_UniformGridData_from_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine the refinement levels into a :py:class:`~.UniformGridData`</span>
<span class="sd">        on the specified :py:class:`~.UniformGrid`.</span>

<span class="sd">        If ``resample`` is True, the data is resampled with multilinear</span>
<span class="sd">        interpolation.</span>

<span class="sd">        :param grid: Grid onto which to resample the data.</span>
<span class="sd">        :type grid: :py:class:`~.UniformGrid`.</span>
<span class="sd">        :param resample: If True, resample the data with multilinear interpolation,</span>
<span class="sd">                         otherwise, use nearest neighbors.</span>
<span class="sd">        :type resample: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">UniformGridData</span><span class="p">(</span>
            <span class="n">grid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_with_spline</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">piecewise_constant</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="n">resample</span><span class="p">)),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.to_UniformGridData"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.to_UniformGridData">[docs]</a>    <span class="k">def</span> <span class="nf">to_UniformGridData</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine the refinement levels into a :py:class:`~.UniformGridData` specified</span>
<span class="sd">        by the given ``shape``, ``x0``, and ``dx`` or ``x1``.</span>

<span class="sd">        Additional arguments are sent to the constructor of</span>
<span class="sd">        :py:class:`~.UniformGrid`.</span>

<span class="sd">        If ``resample`` is True, the data is resampled with multilinear</span>
<span class="sd">        interpolation.</span>

<span class="sd">        :param shape: Number of points across all the dimensions.</span>
<span class="sd">        :type shape: 1d NumPy array</span>
<span class="sd">        :param x0: Origin.</span>
<span class="sd">        :type x0: 1d NumPy array, or None</span>
<span class="sd">        :param x1: Grid corner. If None, it will be inferred.</span>
<span class="sd">        :type x1:  1d NumPy array, or None</span>
<span class="sd">        :param dx: Grid spacing. If None, it will be inferred.</span>
<span class="sd">        :type dx: 1d NumPy array, or None</span>
<span class="sd">        :param resample: If True, resample the data with multilinear interpolation,</span>
<span class="sd">                         otherwise, use nearest neighbors.</span>
<span class="sd">        :type resample: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">UniformGrid</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_UniformGridData_from_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.merge_refinement_levels"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.merge_refinement_levels">[docs]</a>    <span class="k">def</span> <span class="nf">merge_refinement_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine all the available data and resample it grid that encompasses all the</span>
<span class="sd">        components and has resolution of the finest refinement level.</span>

<span class="sd">        When ``resample`` is True, data from coarser refinement levels is</span>
<span class="sd">        resampled with multilinear interpolation, otherwise the nearest</span>
<span class="sd">        neighbors are used.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            For most practical purposes, using this function is an overkill.</span>
<span class="sd">            This can be a very expensive operation and require a lot of memory.</span>
<span class="sd">            Prefer :py:meth:`to_UniformGridData` when possible.</span>

<span class="sd">        :param resample: If True, resample the data with multilinear interpolation,</span>
<span class="sd">                         otherwise, use nearest neighbors.</span>
<span class="sd">        :type resample: bool</span>

<span class="sd">        :returns: New :py:class:`~.UniformGridData` with the resolution of the</span>
<span class="sd">                  finest refinement level.</span>
<span class="sd">        :rtype: :py:class:`~.UniformGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If we have only one refinement level, with one component, we should</span>
        <span class="c1"># just return that.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_component</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># finest_dx can have zero entries, for which a shape of 1 should</span>
        <span class="c1"># correspond. There can zero entries, we substitute them with -1, so</span>
        <span class="c1"># that we can identify them as negative numbers</span>
        <span class="n">new_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx</span> <span class="k">if</span> <span class="n">dx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">finest_dx</span><span class="p">])</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="n">new_dx</span> <span class="o">+</span> <span class="mf">1.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span> <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new_shape</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_UniformGridData</span><span class="p">(</span>
            <span class="n">new_shape</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span>
            <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dx</span><span class="o">=</span><span class="n">new_dx</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="n">iteration</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iteration</span><span class="p">,</span>
            <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the method ``f`` to ``self``, modifying ``self``.</span>
<span class="sd">        This is used to transform the commands from returning an object</span>
<span class="sd">        to modifying ``self``.</span>
<span class="sd">        The function has to return a new copy of the object (not a reference).</span>

<span class="sd">        :param f: Function to apply to ``self``.</span>
<span class="sd">        :type f:  callable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_data_dict</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">grid_data_dict</span>

    <span class="k">def</span> <span class="nf">_apply_binary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a binary function to the data of ``self`` and ``other``.</span>

<span class="sd">        :param function: Function to apply to all the data in the various</span>
<span class="sd">        refinement levels.</span>
<span class="sd">        :type function: callable</span>

<span class="sd">        :return: New :py:class:`~.HierarchicalGridData` with function applied to</span>
<span class="sd">        ``self.data`` and ``other.data``.</span>
<span class="sd">        :rtype: :py:class:`~.HierarchicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We only know what how to h</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">refinement_levels</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Refinement levels incompatible&quot;</span><span class="p">)</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">function</span><span class="p">(</span><span class="n">data_self</span><span class="p">,</span> <span class="n">data_other</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">data_self</span><span class="p">,</span> <span class="n">data_other</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">all_components</span>
                <span class="p">)</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">function</span><span class="p">(</span><span class="n">data_self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">for</span> <span class="n">data_self</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_data</span><span class="p">)</span>

        <span class="c1"># If we are here, it is because we cannot add the two objects</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;I don&#39;t know how to combine these objects&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a reduction to the data.</span>

<span class="sd">        :param function: Reduction to apply to all the data in the various</span>
<span class="sd">        refinement levels</span>
<span class="sd">        :type function: callable</span>

<span class="sd">        :return: Output of the reduction on the data.</span>
<span class="sd">        :rtype: return type of ``reduction``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assume reduction is np.min, we want the real minimum, so we have to</span>
        <span class="c1"># take the reduction of the reduction</span>
        <span class="k">return</span> <span class="n">reduction</span><span class="p">(</span>
            <span class="c1"># Here we are accessing _apply_reduction, which is a protected</span>
            <span class="c1"># member, so we ignore potential complaints.</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="c1"># skipcq: PYL-W0212</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">_apply_reduction</span><span class="p">(</span><span class="n">reduction</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a unary function to the data.</span>

<span class="sd">        :param function: Function to apply to all the data in the various</span>
<span class="sd">        refinement levels</span>
<span class="sd">        :type function: callable</span>

<span class="sd">        :return: New :py:class:`~.HierarchicalGridData` with function applied to</span>
<span class="sd">        the data.</span>
<span class="sd">        :rtype: :py:class:`~.HierarchicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">function</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_component_method</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">method_returns_list</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call a method on each component and return the result as a</span>
<span class="sd">        :py:class:`~.HierarchicalGridData`.</span>

<span class="sd">        :param method_name: a string that identifies one of the methods in</span>
<span class="sd">        :py:class:`~.UniformGridData`.</span>
<span class="sd">        :type method_name: str</span>

<span class="sd">        :param method_returns_list: If True, the method is expected to return a</span>
<span class="sd">                                    list, one :py:class:`~.UniformGridData` per</span>
<span class="sd">                                    dimension (e.g,</span>
<span class="sd">                                    :py:meth:`HierarchicalGridData.gradient`,</span>
<span class="sd">                                    :py:meth:`HierarchicalGridData.coordinates`).</span>
<span class="sd">        :type method_returns_list: bool</span>

<span class="sd">        :return: New :py:class:`~.HierarchicalGridData` with function applied to the data</span>
<span class="sd">        :rtype: :py:class:`~.HierarchicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;method_name has to be a string (but it is </span><span class="si">{</span><span class="n">method_name</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_component</span><span class="p">,</span> <span class="n">method_name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;UniformGridData does not have a method with name </span><span class="si">{</span><span class="n">method_name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Here we get the method as a function with getattr(data, method_name),</span>
        <span class="c1"># then we apply this function with arguments *args and **kwargs</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span>
        <span class="p">]</span>
        <span class="c1"># There are two possibilities: new data is a list of UniformGridData</span>
        <span class="c1"># (when method_returns_list is False), alternatively it is a list of</span>
        <span class="c1"># lists of UniformGridData</span>

        <span class="c1"># First, the case in which the method returns a UniformGridData (and not</span>
        <span class="c1"># a list of UniformGridData)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">method_returns_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_data</span><span class="p">)</span>

        <span class="c1"># Second, we have a list of UniformGridData</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)([</span><span class="n">data</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">new_data</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dimensions</span><span class="p">)</span>
        <span class="p">]</span>

<div class="viewcode-block" id="HierarchicalGridData.partial_derived"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.partial_derived">[docs]</a>    <span class="k">def</span> <span class="nf">partial_derived</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :py:class:`~.HierarchicalGridData` that is the numerical</span>
<span class="sd">        order-differentiation of the present grid_data along a given direction.</span>
<span class="sd">        (order = number of derivatives, ie ``order=2`` is second derivative)</span>

<span class="sd">        The derivative is calulated as centered differencing in the interior</span>
<span class="sd">        and one-sided derivatives at the boundaries. Higher orders are computed</span>
<span class="sd">        applying the same rule recursively.</span>

<span class="sd">        The output has the same shape of ``self``.</span>

<span class="sd">        :param order: Order of derivative (e.g. 2 = second derivative).</span>
<span class="sd">        :type order: int</span>
<span class="sd">        :param direction: Direction of the partial derivative.</span>
<span class="sd">        :type direction: int</span>

<span class="sd">        :returns:  New :py:class:`~.HierarchicalGridData` with derivative.</span>
<span class="sd">        :rtype:    :py:class:`~.HierarchicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_component_method</span><span class="p">(</span>
            <span class="s2">&quot;partial_derived&quot;</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.gradient"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.gradient">[docs]</a>    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list :py:class:`~.HierarchicalGridData` that are the numerical</span>
<span class="sd">        order-differentiation of the present grid_data along all the directions.</span>
<span class="sd">        (order = number of derivatives, ie ``order=2`` is second derivative)</span>

<span class="sd">        The derivative is calulated as centered differencing in the interior</span>
<span class="sd">        and one-sided derivatives at the boundaries. Higher orders are computed</span>
<span class="sd">        applying the same rule recursively.</span>

<span class="sd">        The output has the same shape of self.</span>

<span class="sd">        :param order: Order of derivative (e.g. 2 = second derivative).</span>
<span class="sd">        :type order: int</span>
<span class="sd">        :returns: list of :py:class:`~.HierarchicalGridData` with partial</span>
<span class="sd">                  derivative along all the directions.</span>
<span class="sd">        :rtype:  list of :py:class:`~.HierarchicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_component_method</span><span class="p">(</span>
            <span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="n">method_returns_list</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.partial_derive"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.partial_derive">[docs]</a>    <span class="k">def</span> <span class="nf">partial_derive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a numerical differentiatin along the specified direction.</span>

<span class="sd">        The derivative is calulated as centered differencing in the interior</span>
<span class="sd">        and one-sided derivatives at the boundaries. Higher orders are computed</span>
<span class="sd">        applying the same rule recursively.</span>

<span class="sd">        The output has the same shape of ``self``.</span>

<span class="sd">        :param order: Order of derivative (e.g. 2 = second derivative).</span>
<span class="sd">        :type order: int</span>
<span class="sd">        :param direction: Direction of the partial derivative.</span>
<span class="sd">        :type direction: int</span>

<span class="sd">        :returns: Derivative along the specified direction.</span>
<span class="sd">        :rtype: list of :py:class:`~.HierarchicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partial_derived</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.sliced"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.sliced">[docs]</a>    <span class="k">def</span> <span class="nf">sliced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.HierarchicalGridData` obtained slicing the current one.</span>

<span class="sd">        ``cut`` specifies how to slice the data. It has to be an array with the</span>
<span class="sd">        same number of dimensions of the data. In the entries where ``cut`` is</span>
<span class="sd">        None, that dimension is kept, where it is a number, the data is cut</span>
<span class="sd">        fixing that coordinate. For example, for a 2D array, if ``cut`` is</span>
<span class="sd">        ``[None, 2]``, the cut will be with ``y = 2``.</span>

<span class="sd">        If ``resample`` is True, you can cut at any point and we will compute</span>
<span class="sd">        the values with multilinear interpolation. If ``resample`` is False, we</span>
<span class="sd">        will use the data already available.</span>

<span class="sd">        In doing this, dimensions that are only one grid point are lost.</span>

<span class="sd">        :param cut: How to slice the array. None entries mean &quot;keep that dimension&quot;.</span>
<span class="sd">        :type cut:  array or list with dimension</span>
<span class="sd">        :param resample: Whether to use multilinear interpolation to compute the</span>
<span class="sd">                         data or simply use the value of the closest point.</span>
<span class="sd">        :type resample: bool</span>

<span class="sd">        :returns: A sliced :py:class:`~.HierachicalGridData`.</span>
<span class="sd">        :rtype: :py:class:`~.HierachicalGridData`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We can use _call_component_method here because we have to handle the</span>
        <span class="c1"># errors</span>

        <span class="c1"># A HierarchicalGridData can be formed by multiple components (e.g., one</span>
        <span class="c1"># for each MPI rank). When we slice it, some components do not</span>
        <span class="c1"># contribute at all to the result. For example, if we ask for the xy</span>
        <span class="c1"># plane and a component has zmin = 3, the component should be excluded.</span>
        <span class="c1"># The slice method raises an error when the cut is outside the grid, here</span>
        <span class="c1"># we capture those errors and ignore the components that raised them.</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_components</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">sliced</span><span class="p">(</span><span class="n">cut</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;Cut point is outside the grid&quot;</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="c1"># Otherwise, do nothing</span>
                <span class="k">pass</span>  <span class="c1"># Ignore the component</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cut point is outside the grid&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.slice"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.slice">[docs]</a>    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cut</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Slice the data along given direction.</span>

<span class="sd">        ``cut`` specifies how to slice the data. It has to be an array with the</span>
<span class="sd">        same number of dimensions of the data. In the entries where ``cut`` is</span>
<span class="sd">        None, that dimension is kept, where it is a number, the data is cut</span>
<span class="sd">        fixing that coordinate. For example, for a 2D array, if ``cut`` is</span>
<span class="sd">        ``[None, 2]``, the cut will be with ``y = 2``.</span>

<span class="sd">        If ``resample`` is True, you can cut at any point and we will compute</span>
<span class="sd">        the values with multilinear interpolation. If ``resample`` is False, we</span>
<span class="sd">        will use the data already available.</span>

<span class="sd">        In doing this, dimensions that are only one grid point are lost.</span>

<span class="sd">        :param cut: How to slice the array. None entries mean &quot;keep that dimension&quot;.</span>
<span class="sd">        :type cut:  array or list with dimension</span>
<span class="sd">        :param resample: Whether to use multilinear interpolation to compute the</span>
<span class="sd">                         data or simply use the value of the closest point.</span>
<span class="sd">        :type resample: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sliced</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="n">cut</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">)</span></div>

<div class="viewcode-block" id="HierarchicalGridData.coordinates"><a class="viewcode-back" href="../../grid_data_ref.html#kuibit.grid_data.HierarchicalGridData.coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return coordinates as a list of :py:class:`~.HierarchicalGridData`.</span>

<span class="sd">        Useful for computations involving coordinates.</span>

<span class="sd">        :returns: Coordinates.</span>
<span class="sd">        :rtype: list of :py:class:`~.HierarchicalGridData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_component_method</span><span class="p">(</span>
            <span class="s2">&quot;coordinates&quot;</span><span class="p">,</span> <span class="n">method_returns_list</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="s2">&quot;Available refinement levels (components):</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">ref_level</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">refinement_levels</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ref_level</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ref_level</span><span class="p">])</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Spacing at coarsest level (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_coarsest_level</span><span class="si">}</span><span class="s2">): &quot;</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">coarsest_dx</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Spacing at finest level (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_finest_level</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">finest_dx</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">ret</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">kuibit 1.0.0b0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">kuibit.grid_data</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020-2021, Gabriele Bozzola.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.2.
    </div>
  </body>
</html>