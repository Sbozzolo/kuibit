

<!doctype html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>kuibit.timeseries &#8212; kuibit 1.1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bizstyle.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">kuibit 1.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">kuibit.timeseries</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for kuibit.timeseries</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="c1"># Copyright (C) 2020-2021 Gabriele Bozzola</span>
<span class="c1">#</span>
<span class="c1"># Based on by code originally developed by Wolfgang Kastaun. See, GitHub,</span>
<span class="c1"># wokast/PyCactus/PostCactus/timeseries.py</span>
<span class="c1">#</span>
<span class="c1"># This program is free software; you can redistribute it and/or modify it under</span>
<span class="c1"># the terms of the GNU General Public License as published by the Free Software</span>
<span class="c1"># Foundation; either version 3 of the License, or (at your option) any later</span>
<span class="c1"># version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1"># ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
<span class="c1"># FOR A PARTICULAR PURPOSE. See the GNU General Public License for more</span>
<span class="c1"># details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License along with</span>
<span class="c1"># this program; if not, see &lt;https://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;The :py:mod:`~.timeseries` module provides a representation of time series</span>
<span class="sd">and convenience functions to create :py:class:`~.TimeSeries`.</span>

<span class="sd">:py:class:`~.TimeSeries` can be evenly or unevenly sampled are rich in features.</span>
<span class="sd">They support all the mathematical operations and operators you may expect, and</span>
<span class="sd">have additional methods, which include ones for taking derivatives, integrals,</span>
<span class="sd">apply windows, smooth the signal, take Fourier transform, and more. Most of</span>
<span class="sd">these methods are available in two flavors: those that return a new</span>
<span class="sd">:py:class:`~.TimeSeries`, and those which modify the object in place. The latter</span>
<span class="sd">have names with imperative verbs.</span>

<span class="sd">:py:class:`~.TimeSeries` are derived from the :py:class:`~.BaseSeries`, which in</span>
<span class="sd">turn is derived from the abstract class :py:class:`~.BaseNumerical`. Some of the</span>
<span class="sd">capabilities of :py:class:`~.TimeSeries` (e.g., overloading the mathematical</span>
<span class="sd">operators) are implemented in the parent classes.</span>

<span class="sd">The additional functions provided in :py:mod:`~.timeseries` are:</span>

<span class="sd">- :py:func:`~.remove_duplicated_iters` cleans the input arrays by removing duplicated times.</span>
<span class="sd">- :py:func:`~.unfold_phase` takes as argument a NumPy array representing a phase</span>
<span class="sd">  and unfolds it removing all the jumps of 2 pi. This is useful in gravitational</span>
<span class="sd">  wave analysis.</span>
<span class="sd">- :py:func:`~.combine_ts` takes a list of timeseries and removes all the overlapping segments.</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>

<span class="kn">from</span> <span class="nn">kuibit</span> <span class="kn">import</span> <span class="n">frequencyseries</span>
<span class="kn">from</span> <span class="nn">kuibit.series</span> <span class="kn">import</span> <span class="n">BaseSeries</span>


<div class="viewcode-block" id="remove_duplicated_iters"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.remove_duplicated_iters">[docs]</a><span class="k">def</span> <span class="nf">remove_duplicated_iters</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove overlapping segments from a time series in (t,y).</span>

<span class="sd">    Only the latest of overlapping segments is kept, the rest</span>
<span class="sd">    removed.</span>

<span class="sd">    This function is used for cleaning up simulations with multiple</span>
<span class="sd">    checkpoints.</span>

<span class="sd">    Note, if t = [1, 2, 3, 4, 2, 3] the output will be [1, 2, 3].</span>
<span class="sd">    The &#39;4&#39; is discarded because it is not the last segment. The</span>
<span class="sd">    idea is that if this corresponds to a simulation restart, you</span>
<span class="sd">    may have changed the paramters, so that 4 is not anymore correct.</span>
<span class="sd">    We consider the second restart the &quot;truth&quot;.</span>

<span class="sd">    :param t:  Times.</span>
<span class="sd">    :type t:   1D NumPy array</span>
<span class="sd">    :param y:  Values.</span>
<span class="sd">    :type t:   1D NumPy array</span>

<span class="sd">    :returns:  Strictly monotonic time series.</span>
<span class="sd">    :rtype:    :py:class:`~.TimeSeries`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Let&#39;s unpack this code.</span>
    <span class="c1"># First, we define a new variable t2.</span>
    <span class="c1">#</span>
    <span class="c1"># t2 is essentially the &quot;cumulative minimum&quot; of the times of the time</span>
    <span class="c1"># series: t2[i] is the minimum up to index i</span>
    <span class="c1">#</span>
    <span class="c1"># To be more specific, we walk the time array backwards (t[::-1]) and</span>
    <span class="c1"># we compute the cumulative minima. Then, we reverse the array ([::-1])</span>
    <span class="c1">#</span>
    <span class="c1"># For example, if t = [1, 2, 3, 4, 2, 3]</span>
    <span class="c1"># Then t[::-1] = [3, 2, 4, 3, 2, 1], and</span>
    <span class="c1"># np.minimum.accumulate(t[::-1]) = [3, 2, 2, 2, 2, 1]</span>
    <span class="c1"># Reversing it: t2 = [1, 2, 2, 2, 2, 3]</span>
    <span class="c1">#</span>
    <span class="c1"># If t had no nuplicates t2 and t would be the same.</span>
    <span class="c1"># When t has duplicates, t2 is like t but in place of the duplicates</span>
    <span class="c1"># it has values that are equal or smaller.</span>
    <span class="c1">#</span>
    <span class="c1"># What we want is to have as output [1, 2, 3]</span>
    <span class="c1"># To get that, we compare t and t2. Values that are not duplicated</span>
    <span class="c1"># are those subtracted with the following are positive.</span>
    <span class="c1"># (t[:-1] &lt; t2[1:])</span>

    <span class="c1"># First, we make sure that we are dealing with arrays and not lists</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">t2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">t</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Here we append [True] because the last point is always included</span>
    <span class="n">msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">t</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">t2</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="p">[</span><span class="kc">True</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">msk</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">msk</span><span class="p">])</span></div>


<div class="viewcode-block" id="unfold_phase"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.unfold_phase">[docs]</a><span class="k">def</span> <span class="nf">unfold_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove phase jumps to get a continuous (unfolded) phase.</span>

<span class="sd">    :param phase:     Phase wrapped around the provided jump.</span>
<span class="sd">    :type phase:      1D NumPy array</span>

<span class="sd">    :returns:         Phase plus multiples of pi chosen to minimize jumps.</span>
<span class="sd">    :rtype:           1D NumPy array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span></div>


<div class="viewcode-block" id="combine_ts"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.combine_ts">[docs]</a><span class="k">def</span> <span class="nf">combine_ts</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">prefer_late</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combine several overlapping time series into one.</span>

<span class="sd">    In intervals covered by two or more time series, which data is used depends</span>
<span class="sd">    on the parameter prefer_late. If two segments start at the same time, the</span>
<span class="sd">    longer one gets used.</span>

<span class="sd">    :param series: The timeseries to combine.</span>
<span class="sd">    :type series:  list of :py:class:`~.TimeSeries`</span>
<span class="sd">    :param prefer_late: If true, prefer data that starts later for overlapping</span>
<span class="sd">                        segments, otherwise, use data from the ones that come</span>
<span class="sd">                        earlier.</span>
<span class="sd">    :type prfer_late:   bool</span>

<span class="sd">    :returns:      The combined time series</span>
<span class="sd">    :rtype:        :py:class:`~.TimeSeries`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Late and early can be implemented in one shot by implementing one and</span>
    <span class="c1"># sending t -&gt; -t for the other. For the &quot;straight&quot; way we implement</span>
    <span class="c1"># combine_ts_early.</span>
    <span class="c1">#</span>
    <span class="c1"># Let&#39;s consider a simple example for the reversed case</span>
    <span class="c1"># t1 = [1, 2, 3], t2 = [2, 3, 4], we want to have t = [1, 2, 3, 4]</span>
    <span class="c1"># sign = -1</span>
    <span class="c1"># timeseries = [t2, t1]</span>
    <span class="c1"># times = t2[::-1] = [4, 3, 2]</span>
    <span class="c1"># Next we walk through the remaining elements of the list</span>
    <span class="c1"># We want only to keep those with t &lt; times[-1] = 2 (hence the switch)</span>
    <span class="c1"># In this case msk = [3, 2, 1] &lt; 2 = [False, False, True], so</span>
    <span class="c1"># s_t[msk] = [1] and times = [4, 3, 2, 1].</span>
    <span class="c1"># At the end, we need to reverse the order again</span>

    <span class="c1"># sign is responsible of inverting the sorting key</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">prefer_late</span> <span class="k">else</span> <span class="mi">1</span>

    <span class="c1"># Tuples are compared lexicographically; the first items are compared; if</span>
    <span class="c1"># they are the same then the second items are compared, and so on.</span>
    <span class="c1"># So here we sort by tmin and tmax</span>
    <span class="n">timeseries</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">sign</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">tmin</span><span class="p">,</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">tmax</span><span class="p">))</span>
    <span class="c1"># Now we are going to build up the t and y array, starting with the first</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">timeseries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="n">sign</span><span class="p">]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">timeseries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">[::</span><span class="n">sign</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">timeseries</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="c1"># We need to walk backwards for &quot;prefer_late&quot;</span>
        <span class="n">s_t</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">t</span><span class="p">[::</span><span class="n">sign</span><span class="p">]</span>
        <span class="n">s_y</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">y</span><span class="p">[::</span><span class="n">sign</span><span class="p">]</span>
        <span class="c1"># We only keep those times that we don&#39;t have yet in the array times</span>
        <span class="n">msk</span> <span class="o">=</span> <span class="n">s_t</span> <span class="o">&lt;</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">prefer_late</span> <span class="k">else</span> <span class="n">s_t</span> <span class="o">&gt;</span> <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">s_t</span><span class="p">[</span><span class="n">msk</span><span class="p">])</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">s_y</span><span class="p">[</span><span class="n">msk</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">times</span><span class="p">[::</span><span class="n">sign</span><span class="p">],</span> <span class="n">values</span><span class="p">[::</span><span class="n">sign</span><span class="p">])</span></div>


<div class="viewcode-block" id="TimeSeries"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries">[docs]</a><span class="k">class</span> <span class="nc">TimeSeries</span><span class="p">(</span><span class="n">BaseSeries</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents real or complex valued time series.</span>

<span class="sd">    :py:class:`~.TimeSeries` are defined providing a time list or array and the</span>
<span class="sd">    corresponding values. For example,</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        times = np.linspace(0, 2 * np.pi, 100)</span>
<span class="sd">        values = np.sin(times)</span>

<span class="sd">        ts = TimeSeries(times, values)</span>


<span class="sd">    Times cannot be empty or not monotonically increasing.</span>
<span class="sd">    Times and values must have the same length.</span>

<span class="sd">    TimeSeries are well-behaved classed, many operations and methods are</span>
<span class="sd">    implemented. For instance, you can sum/multiply two :py:class:`~.TimeSeries`.</span>

<span class="sd">    NumPy acts on TimeSeries cleanly, eg. ``np.log10(TimeSeries)`` is a</span>
<span class="sd">    :py:class:`~.TimeSeries` with ``log10(data)``.</span>

<span class="sd">    :py:class:`~.TimeSeries` have methods for smoothing, windowing, extracting phase and</span>
<span class="sd">    more.</span>

<span class="sd">    :ivar t: Times.</span>
<span class="sd">    :vartype t: 1D NumPy array or float</span>
<span class="sd">    :ivar y: Values.</span>
<span class="sd">    :vartype y: 1D NumPy array or float</span>
<span class="sd">    :ivar spline_real: Coefficients for a spline represent of the real part</span>
<span class="sd">                       of y.</span>
<span class="sd">    :vartype spline_real: tuple</span>
<span class="sd">    :ivar spline_imag: Coefficients for a spline represent of the real part</span>
<span class="sd">                       of y.</span>
<span class="sd">    :vartype spline_imag: tuple</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># NOTE: Are you adding a function? Document it in timeseries.rst!</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">guarantee_t_is_monotonic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        When guarantee_t_is_monotonic is True no checks will be perform to make</span>
<span class="sd">        sure that t is monotonically increasing (increasing performance). This</span>
<span class="sd">        should is used internally whenever a new series is returned from self</span>
<span class="sd">        (since we have already checked that t is good.) or in performance</span>
<span class="sd">        critical routines.</span>

<span class="sd">        :param t: Sampling times, need to be strictly increasing.</span>
<span class="sd">        :type t:  1D NumPy array or list</span>

<span class="sd">        :param y: Data samples, can be real or complex valued.</span>
<span class="sd">        :type y:  1D NumPy array or list</span>

<span class="sd">        :param guarantee_t_is_monotonic: The code will assume that t is</span>
<span class="sd">                                         monotonically increasing.</span>
<span class="sd">        :type guarantee_t_is_monotonic: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use BaseClass init</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">guarantee_t_is_monotonic</span><span class="p">)</span>

    <span class="c1"># The following are the setters and getters, so that we can &quot;resolve&quot; .t</span>
    <span class="c1"># and .y</span>

    <span class="c1"># The @property decorator allows us to call .t instead of .t()</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the time.</span>

<span class="sd">        :returns: Times.</span>
<span class="sd">        :rtype: 1d NumPy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is defined BaseClass and it is where the actual data is stored.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>

    <span class="nd">@t</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">t</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="c1"># This is defined BaseClass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">t</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tmin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the starting time.</span>

<span class="sd">        :returns:  Initial time of the timeseries.</span>
<span class="sd">        :rtype:    float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmin</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the final time.</span>

<span class="sd">        :returns:  Final time of the timeseries.</span>
<span class="sd">        :rtype:    float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xmax</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the timestep if the series is regularly sampled,</span>
<span class="sd">        otherwise raise error.</span>

<span class="sd">        :returns: Timestep of the series (if evenly sampled).</span>
<span class="sd">        :rtype: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_regularly_sampled</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Timeseries is not regularly sampled&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the length of the covered time interval.</span>

<span class="sd">        :returns:  Length of time covered by the timeseries (tmax - tmin).</span>
<span class="sd">        :rtype:    float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span>

    <span class="n">duration</span> <span class="o">=</span> <span class="n">time_length</span>

<div class="viewcode-block" id="TimeSeries.time_at_maximum"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.time_at_maximum">[docs]</a>    <span class="k">def</span> <span class="nf">time_at_maximum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the time at which the timeseries is maximum in absolute</span>
<span class="sd">        value.</span>

<span class="sd">        :returns:  Time at absolute maximum.</span>
<span class="sd">        :rtype:    float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_at_abs_maximum_y</span><span class="p">()</span></div>

<div class="viewcode-block" id="TimeSeries.time_at_minimum"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.time_at_minimum">[docs]</a>    <span class="k">def</span> <span class="nf">time_at_minimum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the time at which the timeseries is minimum in absolute</span>
<span class="sd">        value.</span>

<span class="sd">        :returns:  Time at absolute minimum.</span>
<span class="sd">        :rtype:    float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_at_abs_minimum_y</span><span class="p">()</span></div>

<div class="viewcode-block" id="TimeSeries.aligned_at_minimum"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.aligned_at_minimum">[docs]</a>    <span class="k">def</span> <span class="nf">aligned_at_minimum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new timeseries with absolute minimum at t=0.</span>

<span class="sd">        :returns:  Timeseries shifted so that the minimum is a t=0.</span>
<span class="sd">        :rtype:    :py:class:`~.TimeSeries`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_shifted</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">time_at_minimum</span><span class="p">())</span></div>

<div class="viewcode-block" id="TimeSeries.align_at_minimum"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.align_at_minimum">[docs]</a>    <span class="k">def</span> <span class="nf">align_at_minimum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Time shift the series so that the absolute minimum is at t=0.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aligned_at_minimum</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.aligned_at_maximum"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.aligned_at_maximum">[docs]</a>    <span class="k">def</span> <span class="nf">aligned_at_maximum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new timeseries with absolute maximum at t=0.</span>

<span class="sd">        :returns:  Timeseries shifted so that the maximum is a t=0.</span>
<span class="sd">        :rtype:    :py:class:`~.TimeSeries`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_shifted</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">time_at_maximum</span><span class="p">())</span></div>

<div class="viewcode-block" id="TimeSeries.align_at_maximum"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.align_at_maximum">[docs]</a>    <span class="k">def</span> <span class="nf">align_at_maximum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Time shift the series so that the absolute maximum is at t=0.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aligned_at_maximum</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.regular_resampled"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.regular_resampled">[docs]</a>    <span class="k">def</span> <span class="nf">regular_resampled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new timeseries resampled to regularly spaced times,</span>
<span class="sd">        with the same number of points.</span>

<span class="sd">        :returns: Regularly resampled time series.</span>
<span class="sd">        :rtype:   :py:class:`~.TimeSeries`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmax</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">(</span><span class="n">t</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.regular_resample"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.regular_resample">[docs]</a>    <span class="k">def</span> <span class="nf">regular_resample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resample the timeseries to regularly spaced times,</span>
<span class="sd">        with the same number of points.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regular_resampled</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.fixed_frequency_resampled"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.fixed_frequency_resampled">[docs]</a>    <span class="k">def</span> <span class="nf">fixed_frequency_resampled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a  :py:class:`~.TimeSeries` with same tmin and tmax</span>
<span class="sd">        but resampled at a fixed frequency. The final time will change</span>
<span class="sd">        if the frequency does not lead a integer number of timesteps.</span>

<span class="sd">        :param frequency: Sampling rate.</span>
<span class="sd">        :type frequency: float</span>
<span class="sd">        :returns:  Time series resampled with given frequency.</span>
<span class="sd">        :rtype:   :py:class:`~.TimeSeries`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dt</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Frequency too short for resampling&quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_length</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
        <span class="c1"># We have to add one to n, so that we can include the tmax point</span>
        <span class="n">new_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampled</span><span class="p">(</span><span class="n">new_times</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.fixed_frequency_resample"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.fixed_frequency_resample">[docs]</a>    <span class="k">def</span> <span class="nf">fixed_frequency_resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resample the timeseries to regularly spaced times with the given frequency.</span>
<span class="sd">        The final time will change if the frequency does not lead a integer</span>
<span class="sd">        number of timesteps.</span>

<span class="sd">        :param frequency: Sampling rate.</span>
<span class="sd">        :type frequency: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_frequency_resampled</span><span class="p">,</span> <span class="n">frequency</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.fixed_timestep_resample"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.fixed_timestep_resample">[docs]</a>    <span class="k">def</span> <span class="nf">fixed_timestep_resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resample the timeseries to regularly spaced times with given timestep.</span>
<span class="sd">        The final time will change if the timestep does not lead a integer</span>
<span class="sd">        number of timesteps.</span>

<span class="sd">        :param timestep: New timestep.</span>
<span class="sd">        :type timestep: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_timestep_resampled</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.fixed_timestep_resampled"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.fixed_timestep_resampled">[docs]</a>    <span class="k">def</span> <span class="nf">fixed_timestep_resampled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.TimeSeries` with evenly spaced with the given</span>
<span class="sd">        timestep. The final time will change if the timestep does not lead a</span>
<span class="sd">        integer number of timesteps.</span>

<span class="sd">        :param timestep: New timestep.</span>
<span class="sd">        :type timestep: float</span>
<span class="sd">        :returns:  Time series resampled with given timestep.</span>
<span class="sd">        :rtype:   :py:class:`~.TimeSeries`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">timestep</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Timestep larger then duration of the TimeSeries&quot;</span><span class="p">)</span>
        <span class="n">frequency</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">timestep</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_frequency_resampled</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.zero_padded"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.zero_padded">[docs]</a>    <span class="k">def</span> <span class="nf">zero_padded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :py:class:`~.TimeSeries` that is zero-padded and that has</span>
<span class="sd">        in total ``N`` points.</span>

<span class="sd">        .. note::</span>

<span class="sd">            ``N`` is the final number of points, not the number of points added.</span>

<span class="sd">        This operation will work only if the series is equispaced.</span>

<span class="sd">        :param N: Total number of points of the output.</span>
<span class="sd">        :type N: int</span>

<span class="sd">        :returns: A new timeseries with in total N points where all</span>
<span class="sd">                  the trailing ones are zero.</span>
<span class="sd">        :rtype: :py:class:`~.TimeSeries`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N_new_zeros</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">N_new_zeros</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Zero-padding cannot decrease the number of points&quot;</span>
            <span class="p">)</span>

        <span class="n">new_zeros_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmax</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmax</span> <span class="o">+</span> <span class="n">N_new_zeros</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span>
            <span class="n">N_new_zeros</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">new_zeros_t</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_new_zeros</span><span class="p">)),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.zero_pad"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.zero_pad">[docs]</a>    <span class="k">def</span> <span class="nf">zero_pad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pad the timeseries with zeros so that it has a total of N points.</span>

<span class="sd">        This operation will work only if the timeseries is equispaced and if N</span>
<span class="sd">        is larger than the number of points already present.</span>

<span class="sd">        .. note::</span>

<span class="sd">            ``N`` is the final number of points, not the number of points added.</span>

<span class="sd">        :param N: Total number new points with zeros at the end.</span>
<span class="sd">        :type N: int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zero_padded</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.mean_removed"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.mean_removed">[docs]</a>    <span class="k">def</span> <span class="nf">mean_removed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :py:class:`~.TimeSeries` with mean removed, so that its new</span>
<span class="sd">        total average is zero.</span>

<span class="sd">        :returns: A new :py:class:`~.TimeSeries` with zero mean.</span>
<span class="sd">        :rtype: :py:class:`~.TimeSeries`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span></div>

<div class="viewcode-block" id="TimeSeries.mean_remove"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.mean_remove">[docs]</a>    <span class="k">def</span> <span class="nf">mean_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the mean value from the data.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_removed</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.initial_time_removed"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.initial_time_removed">[docs]</a>    <span class="k">def</span> <span class="nf">initial_time_removed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_init</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :py:class:`~.TimeSeries` without the initial ``time_init`` amount of</span>
<span class="sd">        time.</span>

<span class="sd">        When ``tmin = 0``, this is the same as cropping, otherwise the</span>
<span class="sd">        difference is that in one case the time interval is specified, whereas</span>
<span class="sd">        in the other (cropping) the new ``tmin`` is specified.</span>

<span class="sd">        If a series goes from t=-1 to t=10 and you set time_init=2,</span>
<span class="sd">        the series will go from t=1 to t=10.</span>

<span class="sd">        :param time_init: Amount of time to be removed from the beginning.</span>
<span class="sd">        :type time_init: float</span>

<span class="sd">        :returns: A new :py:class:`~.TimeSeries` without the initial ``time_init``.</span>
<span class="sd">        :rtype: :py:class:`~.TimeSeries`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cropped</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tmin</span> <span class="o">+</span> <span class="n">time_init</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.initial_time_remove"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.initial_time_remove">[docs]</a>    <span class="k">def</span> <span class="nf">initial_time_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_init</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the first ``time_init`` amount of time in the timeseries.</span>

<span class="sd">        When ``tmin = 0``, this is the same as cropping, otherwise the</span>
<span class="sd">        difference is that in one case the time interval is specified, whereas</span>
<span class="sd">        in the other (cropping) the new ``tmin`` is specified.</span>

<span class="sd">        :param time_init: Amount of time to be removed from the beginning.</span>
<span class="sd">        :type time_init: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_time_removed</span><span class="p">,</span> <span class="n">time_init</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.final_time_removed"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.final_time_removed">[docs]</a>    <span class="k">def</span> <span class="nf">final_time_removed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :py:class:`~.TimeSeries` without the final ``time_end`` amount of</span>
<span class="sd">        time.</span>

<span class="sd">        If a series goes from t=-1 to t=10 and you set time_end=2,</span>
<span class="sd">        the series will go from t=-1 to t=8.</span>

<span class="sd">        :param time_end: Amount of time to be removed from the end.</span>
<span class="sd">        :type time_end: float</span>

<span class="sd">        :returns: A new :py:class:`~.TimeSeries` without the final ``time_end``.</span>
<span class="sd">        :rtype: :py:class:`~.TimeSeries`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cropped</span><span class="p">(</span><span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tmax</span> <span class="o">-</span> <span class="n">time_end</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.final_time_remove"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.final_time_remove">[docs]</a>    <span class="k">def</span> <span class="nf">final_time_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the final ``time_end`` amount of time in the timeseries.</span>

<span class="sd">        :param time_end: Amount of time to be removed from the end.</span>
<span class="sd">        :type time_end: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_time_removed</span><span class="p">,</span> <span class="n">time_end</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.time_shifted"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.time_shifted">[docs]</a>    <span class="k">def</span> <span class="nf">time_shifted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tshift</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new timeseries with time shifted by ``tshift`` so that</span>
<span class="sd">        what was t = 0 will be ``tshift``.</span>

<span class="sd">        :param tshift: Amount of time to shift.</span>
<span class="sd">        :type tshift: float</span>
<span class="sd">        :returns: A new :py:class:`~.TimeSeries` with time shifted.</span>
<span class="sd">        :rtype: :py:class:`~.TimeSeries`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">+</span> <span class="n">tshift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.time_shift"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.time_shift">[docs]</a>    <span class="k">def</span> <span class="nf">time_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tshift</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shift the timeseries by ``tshift`` so that what was t = 0 will be ``tshift``.</span>

<span class="sd">        :param N: Amount of time to shift.</span>
<span class="sd">        :type N: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_shifted</span><span class="p">,</span> <span class="n">tshift</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.phase_shifted"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.phase_shifted">[docs]</a>    <span class="k">def</span> <span class="nf">phase_shifted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pshift</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.TimeSeries` with complex phase shifted by ``pshift``.</span>
<span class="sd">        If the signal is real, it is turned complex with phase of ``pshift``.</span>

<span class="sd">        :param pshift: Amount of phase to shift.</span>
<span class="sd">        :type pshift: float</span>
<span class="sd">        :returns: A new :py:class:`~.TimeSeries` with phase shifted.</span>
<span class="sd">        :rtype: :py:class:`~.TimeSeries`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">pshift</span><span class="p">))</span></div>

<div class="viewcode-block" id="TimeSeries.phase_shift"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.phase_shift">[docs]</a>    <span class="k">def</span> <span class="nf">phase_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pshift</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shift the complex phase timeseries by ``pshift``. If the signal is real,</span>
<span class="sd">        it is turned complex with phase of ``pshift``.</span>

<span class="sd">        :param pshift: Amount of phase to shift.</span>
<span class="sd">        :type pshift: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_shifted</span><span class="p">,</span> <span class="n">pshift</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.time_unit_changed"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.time_unit_changed">[docs]</a>    <span class="k">def</span> <span class="nf">time_unit_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.TimeSeries` with time scaled by ``unit``.</span>

<span class="sd">        This amounts to sending t to ``t / unit``. For example, if initially the</span>
<span class="sd">        units where seconds, with unit=1e-3 the new units will be milliseconds.</span>

<span class="sd">        When inverse is True, the opposite is done and t is sent to ``t *</span>
<span class="sd">        unit``. This is useful to convert geometrized units to physical units</span>
<span class="sd">        with :py:mod:`~.unitconv`. For example,</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Gravitational waves in geometrized units</span>
<span class="sd">            gw_cu = TimeSeries(...)</span>
<span class="sd">            # Gravitational waves in seconds, assuming a mass of 1 M_sun</span>
<span class="sd">            CU = uc.geom_umass_msun(1)</span>
<span class="sd">            gw_s = gw_cu.time_unit_changed(CU.time, inverse=True)</span>

<span class="sd">        :param unit: New time unit.</span>
<span class="sd">        :type unit: float</span>
<span class="sd">        :param inverse: If True, time = 1 -&gt; time = unit, otherwise</span>
<span class="sd">                        time = unit -&gt; 1.</span>
<span class="sd">        :type inverse: bool</span>

<span class="sd">        :returns: A :py:class:`~.TimeSeries` with new time unit.</span>
<span class="sd">        :rtype: :py:class:`~.TimeSeries`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">unit</span> <span class="k">if</span> <span class="n">inverse</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">unit</span>
        <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">*</span> <span class="n">factor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.time_unit_change"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.time_unit_change">[docs]</a>    <span class="k">def</span> <span class="nf">time_unit_change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rescale time units by unit.</span>

<span class="sd">        This amounts to sending t to ``t / unit``. For example, if initially the</span>
<span class="sd">        units where seconds, with unit=1e-3 the new units will be milliseconds.</span>

<span class="sd">        When inverse is True, the opposite is done and t is sent to ``t *</span>
<span class="sd">        unit``. This is useful to convert geometrized units to physical units</span>
<span class="sd">        with :py:mod:`~.unitconv`. For example,</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Gravitational waves in geometrized units</span>
<span class="sd">            gw_cu = TimeSeries(...)</span>
<span class="sd">            # Gravitational waves in seconds, assuming a mass of 1 M_sun</span>
<span class="sd">            CU = uc.geom_umass_msun(1)</span>
<span class="sd">            gw_s = gw_cu.time_unit_changed(CU.time, inverse=True)</span>

<span class="sd">        :param unit: New time unit.</span>
<span class="sd">        :type unit: float</span>
<span class="sd">        :param inverse: If True, time = 1 -&gt; time = unit, otherwise</span>
<span class="sd">                        time = unit -&gt; 1.</span>
<span class="sd">        :type inverse: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_unit_changed</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">inverse</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.redshifted"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.redshifted">[docs]</a>    <span class="k">def</span> <span class="nf">redshifted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :py:class:`~.TimeSeries` with time rescaled so that frequencies</span>
<span class="sd">        are redshifted by ``1 + z``.</span>

<span class="sd">        :param z: Redshift factor.</span>
<span class="sd">        :type z: float</span>

<span class="sd">        :returns: A new redshifted :py:class:`~.TimeSeries`.</span>
<span class="sd">        :rtype: :py:class:`~.TimeSeries`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_unit_changed</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.redshift"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.redshift">[docs]</a>    <span class="k">def</span> <span class="nf">redshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply redshift to the data by rescaling the time so that the frequencies</span>
<span class="sd">        are redshifted by ``1 + z``.</span>

<span class="sd">        :param z: Redshift factor.</span>
<span class="sd">        :type z: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">redshifted</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.unfolded_phase"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.unfolded_phase">[docs]</a>    <span class="k">def</span> <span class="nf">unfolded_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_of_zero_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the complex phase of a complex-valued signal such that no phase</span>
<span class="sd">        wrap-around occur, i.e. if the input is continuous, so is the output.</span>
<span class="sd">        Optionally, add a phase shift such that phase is zero at the given time.</span>

<span class="sd">        :param t_of_zero_phase: Time at which the phase is set to zero.</span>
<span class="sd">        :type t_of_zero_phase:   float or None</span>

<span class="sd">        :returns:   Continuous complex phase.</span>
<span class="sd">        :rtype:     :py:class:`~.TimeSeries`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">unfold_phase</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">t_of_zero_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">(</span><span class="n">t_of_zero_phase</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="TimeSeries.phase_angular_velocity"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.phase_angular_velocity">[docs]</a>    <span class="k">def</span> <span class="nf">phase_angular_velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_splines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tsmooth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the phase angular velocity, i.e. the time derivative of the</span>
<span class="sd">        complex phase.</span>

<span class="sd">        Optionally smooth the with a savgol filter with smoothing length</span>
<span class="sd">        tsmooth and order order. If you do so, the timeseries is resampled to</span>
<span class="sd">        regular timesteps.</span>

<span class="sd">        :param use_splines: Wheter to use splines of finite differencing for</span>
<span class="sd">                            the derivative.</span>
<span class="sd">        :type use_splines: bool</span>
<span class="sd">        :param tsmooth: Time over which smoothing is applied.</span>
<span class="sd">        :type tsmooth: float</span>
<span class="sd">        :param order: Order of the for the savgol smoothing.</span>
<span class="sd">        :type order: int</span>

<span class="sd">        :returns:  Time derivative of the complex phase.</span>
<span class="sd">        :rtype:    :py:class:`~.TimeSeries`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">use_splines</span><span class="p">:</span>
            <span class="n">ret_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unfolded_phase</span><span class="p">()</span><span class="o">.</span><span class="n">spline_differentiated</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unfolded_phase</span><span class="p">()</span><span class="o">.</span><span class="n">differentiated</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">tsmooth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret_value</span><span class="o">.</span><span class="n">savgol_smooth_time</span><span class="p">(</span><span class="n">tsmooth</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret_value</span></div>

<div class="viewcode-block" id="TimeSeries.phase_frequency"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.phase_frequency">[docs]</a>    <span class="k">def</span> <span class="nf">phase_frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_splines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tsmooth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the phase frequency, i.e. the time derivative</span>
<span class="sd">        of the complex phase divided by 2 pi.</span>

<span class="sd">        Optionally smooth the with a savgol filter with smoothing length</span>
<span class="sd">        tsmooth and order order. If you do so, the timeseries is resampled</span>
<span class="sd">        to regular timesteps.</span>

<span class="sd">        :param use_splines: Wheter to use splines of finite differencing for</span>
<span class="sd">                            the derivative.</span>
<span class="sd">        :type use_splines: bool</span>
<span class="sd">        :param tsmooth: Time over which smoothing is applied.</span>
<span class="sd">        :type tsmooth: float</span>
<span class="sd">        :param order: Order of the for the savgol smoothing.</span>
<span class="sd">        :type order: int</span>

<span class="sd">        :returns:  Time derivative of the complex phase divided by 2 pi</span>
<span class="sd">        :rtype:    :py:class:`~.TimeSeries`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_angular_velocity</span><span class="p">(</span><span class="n">use_splines</span><span class="p">,</span> <span class="n">tsmooth</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.windowed"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.windowed">[docs]</a>    <span class="k">def</span> <span class="nf">windowed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :py:class:`~.TimeSeries` windowed with ``window_function``.</span>

<span class="sd">        ``window_function`` has to be a function that takes as first argument</span>
<span class="sd">        the number of points of the signal. ``window_function`` can take</span>
<span class="sd">        additional arguments as passed by ``windowed``. Alternatively,</span>
<span class="sd">        ``window_function`` can be a string with the name of the window</span>
<span class="sd">        function, if this is already implemented in :py:class:`~.TimeSeries`</span>
<span class="sd">        (e.g., ``tukey``).</span>

<span class="sd">        :param window_function: Window function to apply to the timeseries.</span>
<span class="sd">        :type window_function: callable or str</span>

<span class="sd">        :returns:  New windowed :py:class:`~.TimeSeries`.</span>
<span class="sd">        :rtype:    :py:class:`~.TimeSeries`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">window_function</span><span class="p">):</span>
            <span class="n">window_array</span> <span class="o">=</span> <span class="n">window_function</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">window_array</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_function</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">window_function_method</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">window_function</span><span class="si">}</span><span class="s2">_windowed&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_function_method</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Window </span><span class="si">{</span><span class="n">window_function</span><span class="si">}</span><span class="s2"> not implemented&quot;</span><span class="p">)</span>
            <span class="n">window_function_callable</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_function_method</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">window_function_callable</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Window function is neither a callable or a string&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.window"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.window">[docs]</a>    <span class="k">def</span> <span class="nf">window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply window_function to the data.</span>

<span class="sd">        ``window_function`` has to be a function that takes as first argument</span>
<span class="sd">        the number of points of the signal. ``window_function`` can take</span>
<span class="sd">        additional arguments as passed by ``windowed``. Alternatively,</span>
<span class="sd">        ``window_function`` can be a string with the name of the window</span>
<span class="sd">        function, if this is already implemented in :py:class:`~.TimeSeries`</span>
<span class="sd">        (e.g., ``tukey``).</span>

<span class="sd">        :param window_function: Window function to apply to the timeseries.</span>
<span class="sd">        :type window_function: callable or str</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">windowed</span><span class="p">,</span> <span class="n">window_function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.tukey_windowed"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.tukey_windowed">[docs]</a>    <span class="k">def</span> <span class="nf">tukey_windowed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :py:class:`~.TimeSeries` with Tukey window with parameter ``alpha``</span>
<span class="sd">        applied.</span>

<span class="sd">        :param alpha: Tukey parameter.</span>
<span class="sd">        :type alpha: float</span>

<span class="sd">        :returns:  New windowed :py:class:`~.TimeSeries`.</span>
<span class="sd">        :rtype:    :py:class:`~.TimeSeries`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">windowed</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">tukey</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.tukey_window"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.tukey_window">[docs]</a>    <span class="k">def</span> <span class="nf">tukey_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply Tukey window with parameter ``alpha``.</span>

<span class="sd">        :param alpha: Tukey parameter.</span>
<span class="sd">        :type alpha: float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">tukey</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.hamming_windowed"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.hamming_windowed">[docs]</a>    <span class="k">def</span> <span class="nf">hamming_windowed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a timeseries with Hamming window applied.</span>

<span class="sd">        :returns:  New windowed :py:class:`~.TimeSeries`.</span>
<span class="sd">        :rtype:    :py:class:`~.TimeSeries`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">windowed</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">hamming</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.hamming_window"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.hamming_window">[docs]</a>    <span class="k">def</span> <span class="nf">hamming_window</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply Hamming window.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">hamming</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.blackman_windowed"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.blackman_windowed">[docs]</a>    <span class="k">def</span> <span class="nf">blackman_windowed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a timeseries with Blackman window applied.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">windowed</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">blackman</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.blackman_window"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.blackman_window">[docs]</a>    <span class="k">def</span> <span class="nf">blackman_window</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply Blackman window.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">blackman</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.savgol_smoothed_time"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.savgol_smoothed_time">[docs]</a>    <span class="k">def</span> <span class="nf">savgol_smoothed_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tsmooth</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a resampled timeseries with uniform timesteps, smoothed with</span>
<span class="sd">        ``savgol_smooth`` with a window that is ``tsmooth`` in time (as opposed</span>
<span class="sd">        to a number of points).</span>

<span class="sd">        :param tsmooth: Time interval over which to smooth.</span>
<span class="sd">        :type tsmooth: float</span>
<span class="sd">        :param order: Order of the filter.</span>
<span class="sd">        :type order: int</span>

<span class="sd">        :returns:  New smoothed and resampled :py:class:`~.TimeSeries`.</span>
<span class="sd">        :rtype:    :py:class:`~.TimeSeries`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_regularly_sampled</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;TimeSeries is not regularly samples. Resampling.&quot;</span><span class="p">,</span>
                <span class="ne">RuntimeWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regular_resampled</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ts</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># The savgol method requires a odd window</span>
        <span class="c1"># If it is not, we add one point</span>
        <span class="n">window</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">tsmooth</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">window</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">window</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="n">window</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">savgol_smoothed</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.savgol_smooth_time"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.savgol_smooth_time">[docs]</a>    <span class="k">def</span> <span class="nf">savgol_smooth_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tsmooth</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resample the timeseries with uniform timesteps, smooth it with</span>
<span class="sd">        ``savgol_smooth`` with a window that is ``tsmooth`` in time (as opposed to a</span>
<span class="sd">        number of points).</span>

<span class="sd">        :param tsmooth: Time interval over which to smooth.</span>
<span class="sd">        :type tsmooth: float</span>
<span class="sd">        :param order: Order of the filter.</span>
<span class="sd">        :type order: int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">savgol_smoothed_time</span><span class="p">,</span> <span class="n">tsmooth</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeSeries.to_FrequencySeries"><a class="viewcode-back" href="../../timeseries_ref.html#kuibit.timeseries.TimeSeries.to_FrequencySeries">[docs]</a>    <span class="k">def</span> <span class="nf">to_FrequencySeries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :py:class:`~.FrequencySeries` that is the Fourier transform of the</span>
<span class="sd">        timeseries.</span>

<span class="sd">        If the signal is not complex, only positive frequencies are kept.</span>

<span class="sd">        If the timeseries is not regularly sampled, it will be resampled before</span>
<span class="sd">        transforming.</span>

<span class="sd">        :: warning:</span>

<span class="sd">            To have meaningful results, you should consider removing the</span>
<span class="sd">            mean and windowing the signal before calling this method!</span>

<span class="sd">        :returns: Fourier Transform.</span>
<span class="sd">        :rtype: :py:class:`~.FrequencySeries`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_regularly_sampled</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;TimeSeries is not regularly samples. Resampling.&quot;</span><span class="p">,</span>
                <span class="ne">RuntimeWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">regular_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regular_resampled</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">regular_ts</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">dt</span> <span class="o">=</span> <span class="n">regular_ts</span><span class="o">.</span><span class="n">dt</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">():</span>
            <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">regular_ts</span><span class="p">),</span> <span class="n">d</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">regular_ts</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>
            <span class="n">fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">fft</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Note the &quot;r&quot;</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">regular_ts</span><span class="p">),</span> <span class="n">d</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
            <span class="n">fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">regular_ts</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># We need the normalization dt to compute physical quantities.</span>
        <span class="c1"># Intuitively, NumPy computes A_k = \sum a_k exp(-2 pi f t), to</span>
        <span class="c1"># transform this into an integral (true Fourier transform), we have to</span>
        <span class="c1"># multiply this by the measure of integration.</span>
        <span class="k">return</span> <span class="n">frequencyseries</span><span class="o">.</span><span class="n">FrequencySeries</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">fft</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">kuibit 1.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">kuibit.timeseries</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020-2021, Gabriele Bozzola.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.4.
    </div>
  </body>
</html>